<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>Chapter11. 원시 값과 객체의 비교 | wally-wally TIL</title>
    <meta name="generator" content="VuePress 1.9.7">
    
    <meta name="description" content="wally-wally&#39;s TIL">
    <meta name="theme-color" content="#3eaf7c">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black">
    
    <link rel="preload" href="/wally-wally-til/assets/css/0.styles.5b0b7f0f.css" as="style"><link rel="preload" href="/wally-wally-til/assets/js/app.f5246800.js" as="script"><link rel="preload" href="/wally-wally-til/assets/js/2.fd76ebd9.js" as="script"><link rel="preload" href="/wally-wally-til/assets/js/43.7be3d9b4.js" as="script"><link rel="prefetch" href="/wally-wally-til/assets/js/10.d9a95bfe.js"><link rel="prefetch" href="/wally-wally-til/assets/js/11.a2a6e0bb.js"><link rel="prefetch" href="/wally-wally-til/assets/js/12.07ea1bdf.js"><link rel="prefetch" href="/wally-wally-til/assets/js/13.1bfbaa6f.js"><link rel="prefetch" href="/wally-wally-til/assets/js/14.90ad19d6.js"><link rel="prefetch" href="/wally-wally-til/assets/js/15.f50c2694.js"><link rel="prefetch" href="/wally-wally-til/assets/js/16.85e8420c.js"><link rel="prefetch" href="/wally-wally-til/assets/js/17.872b0e5a.js"><link rel="prefetch" href="/wally-wally-til/assets/js/18.f1794982.js"><link rel="prefetch" href="/wally-wally-til/assets/js/19.786141e4.js"><link rel="prefetch" href="/wally-wally-til/assets/js/20.88ff03b1.js"><link rel="prefetch" href="/wally-wally-til/assets/js/21.fd903a51.js"><link rel="prefetch" href="/wally-wally-til/assets/js/22.d215abd1.js"><link rel="prefetch" href="/wally-wally-til/assets/js/23.44ffc4f2.js"><link rel="prefetch" href="/wally-wally-til/assets/js/24.01293f45.js"><link rel="prefetch" href="/wally-wally-til/assets/js/25.3ef63158.js"><link rel="prefetch" href="/wally-wally-til/assets/js/26.a467aa9c.js"><link rel="prefetch" href="/wally-wally-til/assets/js/27.9e7ecb66.js"><link rel="prefetch" href="/wally-wally-til/assets/js/28.2ab87b73.js"><link rel="prefetch" href="/wally-wally-til/assets/js/29.4481ba0f.js"><link rel="prefetch" href="/wally-wally-til/assets/js/3.c603572a.js"><link rel="prefetch" href="/wally-wally-til/assets/js/30.19fd5f37.js"><link rel="prefetch" href="/wally-wally-til/assets/js/31.d5bfcc5a.js"><link rel="prefetch" href="/wally-wally-til/assets/js/32.5ee24aeb.js"><link rel="prefetch" href="/wally-wally-til/assets/js/33.11913056.js"><link rel="prefetch" href="/wally-wally-til/assets/js/34.31af5972.js"><link rel="prefetch" href="/wally-wally-til/assets/js/35.9ae3b57d.js"><link rel="prefetch" href="/wally-wally-til/assets/js/36.39511f04.js"><link rel="prefetch" href="/wally-wally-til/assets/js/37.298faa13.js"><link rel="prefetch" href="/wally-wally-til/assets/js/38.04a5a190.js"><link rel="prefetch" href="/wally-wally-til/assets/js/39.02659111.js"><link rel="prefetch" href="/wally-wally-til/assets/js/4.ed8f2e2d.js"><link rel="prefetch" href="/wally-wally-til/assets/js/40.e5fe29a8.js"><link rel="prefetch" href="/wally-wally-til/assets/js/41.2e0f3c4d.js"><link rel="prefetch" href="/wally-wally-til/assets/js/42.604fb7ae.js"><link rel="prefetch" href="/wally-wally-til/assets/js/44.6a25a594.js"><link rel="prefetch" href="/wally-wally-til/assets/js/45.3d5db9fb.js"><link rel="prefetch" href="/wally-wally-til/assets/js/46.f541a5fe.js"><link rel="prefetch" href="/wally-wally-til/assets/js/47.493907b1.js"><link rel="prefetch" href="/wally-wally-til/assets/js/48.8846fba8.js"><link rel="prefetch" href="/wally-wally-til/assets/js/49.180ec634.js"><link rel="prefetch" href="/wally-wally-til/assets/js/5.16508133.js"><link rel="prefetch" href="/wally-wally-til/assets/js/50.43c8c2f2.js"><link rel="prefetch" href="/wally-wally-til/assets/js/51.cf749cf9.js"><link rel="prefetch" href="/wally-wally-til/assets/js/52.99331d67.js"><link rel="prefetch" href="/wally-wally-til/assets/js/53.efc989ab.js"><link rel="prefetch" href="/wally-wally-til/assets/js/54.6d56ccbb.js"><link rel="prefetch" href="/wally-wally-til/assets/js/55.0c06e067.js"><link rel="prefetch" href="/wally-wally-til/assets/js/56.b45e191a.js"><link rel="prefetch" href="/wally-wally-til/assets/js/57.961440e9.js"><link rel="prefetch" href="/wally-wally-til/assets/js/58.a3d99037.js"><link rel="prefetch" href="/wally-wally-til/assets/js/59.55d3c672.js"><link rel="prefetch" href="/wally-wally-til/assets/js/6.c7b54f12.js"><link rel="prefetch" href="/wally-wally-til/assets/js/60.1eb9e815.js"><link rel="prefetch" href="/wally-wally-til/assets/js/61.60cf2957.js"><link rel="prefetch" href="/wally-wally-til/assets/js/62.060bd05f.js"><link rel="prefetch" href="/wally-wally-til/assets/js/63.f005f9ad.js"><link rel="prefetch" href="/wally-wally-til/assets/js/64.a7d460aa.js"><link rel="prefetch" href="/wally-wally-til/assets/js/65.083b5915.js"><link rel="prefetch" href="/wally-wally-til/assets/js/66.3f31ca88.js"><link rel="prefetch" href="/wally-wally-til/assets/js/67.affe2987.js"><link rel="prefetch" href="/wally-wally-til/assets/js/68.58b01f3c.js"><link rel="prefetch" href="/wally-wally-til/assets/js/69.c7491bbb.js"><link rel="prefetch" href="/wally-wally-til/assets/js/7.233f38d3.js"><link rel="prefetch" href="/wally-wally-til/assets/js/70.9c9e05e7.js"><link rel="prefetch" href="/wally-wally-til/assets/js/71.67c4633a.js"><link rel="prefetch" href="/wally-wally-til/assets/js/72.66a1fbf9.js"><link rel="prefetch" href="/wally-wally-til/assets/js/73.cc121e7e.js"><link rel="prefetch" href="/wally-wally-til/assets/js/74.b71f297f.js"><link rel="prefetch" href="/wally-wally-til/assets/js/75.24c397b2.js"><link rel="prefetch" href="/wally-wally-til/assets/js/8.f792d4e1.js"><link rel="prefetch" href="/wally-wally-til/assets/js/9.897445a3.js">
    <link rel="stylesheet" href="/wally-wally-til/assets/css/0.styles.5b0b7f0f.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/wally-wally-til/" class="home-link router-link-active"><img src="/wally-wally-til/logo.png" alt="wally-wally TIL" class="logo"> <span class="site-name can-hide">wally-wally TIL</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/wally-wally-til/til/" class="nav-link router-link-active">
  TIL
</a></div><div class="nav-item"><a href="/wally-wally-til/config/" class="nav-link">
  Config
</a></div><div class="nav-item"><a href="https://wally-wally.kr" target="_blank" rel="noopener noreferrer" class="nav-link external">
  wally-wally
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/wally-wally-til/til/" class="nav-link router-link-active">
  TIL
</a></div><div class="nav-item"><a href="/wally-wally-til/config/" class="nav-link">
  Config
</a></div><div class="nav-item"><a href="https://wally-wally.kr" target="_blank" rel="noopener noreferrer" class="nav-link external">
  wally-wally
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></div> <!----></nav>  <ul class="sidebar-links"><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>Introduction</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading open"><span>JS Deep Dive</span> <span class="arrow down"></span></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/wally-wally-til/til/js-deep-dive/" aria-current="page" class="sidebar-link">Overview</a></li><li><a href="/wally-wally-til/til/js-deep-dive/chapter04.html" class="sidebar-link">Chapter04</a></li><li><a href="/wally-wally-til/til/js-deep-dive/chapter05.html" class="sidebar-link">Chapter05</a></li><li><a href="/wally-wally-til/til/js-deep-dive/chapter06.html" class="sidebar-link">Chapter06</a></li><li><a href="/wally-wally-til/til/js-deep-dive/chapter07.html" class="sidebar-link">Chapter07</a></li><li><a href="/wally-wally-til/til/js-deep-dive/chapter08.html" class="sidebar-link">Chapter08</a></li><li><a href="/wally-wally-til/til/js-deep-dive/chapter09.html" class="sidebar-link">Chapter09</a></li><li><a href="/wally-wally-til/til/js-deep-dive/chapter10.html" class="sidebar-link">Chapter10</a></li><li><a href="/wally-wally-til/til/js-deep-dive/chapter11.html" aria-current="page" class="active sidebar-link">Chapter11</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/wally-wally-til/til/js-deep-dive/chapter11.html#intro-원시-타입과-객체-참조-타입의-큰-차이점" class="sidebar-link">✋ Intro - 원시 타입과 객체(참조) 타입의 큰 차이점</a></li><li class="sidebar-sub-header"><a href="/wally-wally-til/til/js-deep-dive/chapter11.html#_1-원시-값" class="sidebar-link">1. 원시 값</a></li><li class="sidebar-sub-header"><a href="/wally-wally-til/til/js-deep-dive/chapter11.html#_2-객체" class="sidebar-link">2. 객체</a></li></ul></li><li><a href="/wally-wally-til/til/js-deep-dive/chapter12.html" class="sidebar-link">Chapter12</a></li><li><a href="/wally-wally-til/til/js-deep-dive/chapter13.html" class="sidebar-link">Chapter13</a></li><li><a href="/wally-wally-til/til/js-deep-dive/chapter14.html" class="sidebar-link">Chapter14</a></li><li><a href="/wally-wally-til/til/js-deep-dive/chapter15.html" class="sidebar-link">Chapter15</a></li><li><a href="/wally-wally-til/til/js-deep-dive/chapter16.html" class="sidebar-link">Chapter16</a></li><li><a href="/wally-wally-til/til/js-deep-dive/chapter17.html" class="sidebar-link">Chapter17</a></li></ul></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>Effective TypeScript</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>Refactoring</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>Functional Coding</span> <span class="arrow right"></span></p> <!----></section></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h1 id="chapter11-원시-값과-객체의-비교"><a href="#chapter11-원시-값과-객체의-비교" class="header-anchor">#</a> Chapter11. 원시 값과 객체의 비교</h1> <br> <h2 id="intro-원시-타입과-객체-참조-타입의-큰-차이점"><a href="#intro-원시-타입과-객체-참조-타입의-큰-차이점" class="header-anchor">#</a> ✋ Intro - 원시 타입과 객체(참조) 타입의 큰 차이점</h2> <ul><li>원시 타입의 값(원시값)은 <b>변경 불가능한 값(immutable value)</b>이고 객체 타입의 값(객체)은 <b>변경 가능한 값(mutable value)</b>이다.</li> <li>원시 값을 변수에 할당하면 변수에는 <b>실제 값이 저장</b>되고 객체를 변수에 할당하면 변수에는 <b>참조 값이 저장</b>된다.</li> <li>원시 값을 갖는 변수를 다른 변수에 할당하면 원본의 <b>원시 값이 복사되어 전달(값에 의한 전달; pass by value)</b>되고 객체를 가리키는 변수를 다른 변수에 할당하면 원본의 <b>참조 값이 복사되어 전달(참조에 의한 전달; pass by reference)</b>된다.</li></ul> <br> <h2 id="_1-원시-값"><a href="#_1-원시-값" class="header-anchor">#</a> 1. 원시 값</h2> <h3 id="_1-변경-불가능한-값"><a href="#_1-변경-불가능한-값" class="header-anchor">#</a> (1) 변경 불가능한 값</h3> <ul><li>원시 타입의 값, 즉 원시값은 <b>변경 불가능한 값(immutable value)</b>이다.
<ul><li>다시 말해, 한번 생성된 원시 값은 <b>읽기 전용</b> 값으로서 변경할 수 없다는 의미이다.</li> <li>이와 같은 원시 값의 특성에 의해 <u>데이터의 신뢰성</u>을 보장한다.</li></ul></li> <li>이 때 변수가 아닌 값이 변경 불가능하다는 것이 포인트이다.
<ul><li>원시 값 자체를 변경할 수는 없지만 변수는 언제든지 재할당을 통해 변수 값을 변경할 수 있다.</li></ul></li> <li>참고로 변수의 상대 개념인 상수는 재할당이 금지된 변수를 말한다.
<ul><li>상수도 값을 저장하기 위한 메모리 공간이 필요하므로 변수라고 할 수 있지만 상수는 변수에 비해 단 한 번만 할당이 허용되므로 변수 값을 변경할 수 없다.</li></ul></li></ul> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token comment">// const 키워드를 사용해 선언한 변수는 재할당이 금지됨</span>
<span class="token keyword">const</span> obj <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token comment">// 하지만 const 키워드를 사용해 선언한 변수에 할당한 객체는 변경할 수 있음</span>
obj<span class="token punctuation">.</span>a <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>obj<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// {a: 1}</span>
</code></pre></div><ul><li>'Chapter04. 변수'에서 이전에 살펴보았듯이 값을 재할당할 때 이전의 원시 값을 변경하는 것이 아니라 <u>새로운 메모리 공간을 확보</u>하고 <u>재할당한 원시 값을 저장</u>한 후, 변수는 <u>새롭게 재할당한 원시 값을 가리킨다.</u> <ul><li>이 때 변수가 참조하던 메모리 공간의 주소가 바뀌는데 이는 변수에 할당된 원시 값이 변경 불가능한 값이기 때문이다.</li></ul></li></ul> <p><img src="https://user-images.githubusercontent.com/52685250/145706348-cdb3b482-e910-4d76-b4a6-5ff47420945c.JPG" alt="01"></p> <ul><li>불변성을 갖는 원시 값을 할당한 변수는 재할당 이외에 변수 값을 변경할 수 있는 방법이 없다.
<ul><li>만약 다른 방법이 존재한다면 예기치 않게 변수 값이 변경될 수 있다는 것을 의미하며 값의 변경, 즉 상태 변경을 추적하기 어렵게 만든다.</li></ul></li></ul> <br> <h3 id="_2-문자열과-불변성"><a href="#_2-문자열과-불변성" class="header-anchor">#</a> (2) 문자열과 불변성</h3> <ul><li>다른 언어와 다른 자바스크립의 문자열 특성
<ul><li>C에서는 문자열을 문자의 배열로 처리하고 자바에서는 문자열을 <code>String</code> 객체로 처리한다.</li> <li>하지만 자바스크립트에서는 개발자의 편의를 위해 <b>원시 타입인 문자열 타입을 제공</b>한다.</li></ul></li> <li>문자열의 일부 문자 변경해보기
<ul><li>문자열은 <u>유사 배열 객체(array-like object)</u>이면서 <u>이터러블(iterable)</u>이므로 배열과 유사하게 각 문자에 접근할 수 있다.</li> <li>이 때 이미 생성된 문자열의 일부 문자를 변경해도 반영되지 않는데 이는 <b>문자열은 변경 불가능한 값(읽기 전용)</b>이기 때문이다.</li></ul></li></ul> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token keyword">var</span> str <span class="token operator">=</span> <span class="token string">'abcde'</span><span class="token punctuation">;</span>

<span class="token comment">// 문자열은 유사 배열이므로 배열과 유사하게 인덱스를 사용해 각 문자에 접근할 수 있다.</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>str<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 'a'</span>

<span class="token comment">// 원시 값인 문자열이 객체처럼 동작한다.</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>str<span class="token punctuation">.</span>length<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 5</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>str<span class="token punctuation">.</span><span class="token function">toUpperCase</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 'ABCDE'</span>

<span class="token comment">// 하지만 문자열은 원시 값이므로 변경할 수 없다. 이때 에러가 발생하지 않는다는 것에 유의하자.</span>
str<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">'h'</span><span class="token punctuation">;</span>

console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>str<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 'abcde'</span>
</code></pre></div><hr> <h3 id="유사-배열-객체-array-like-object"><a href="#유사-배열-객체-array-like-object" class="header-anchor">#</a> ➕ 유사 배열 객체(array-like object)</h3> <ul><li>말 그대로 배열이 아닌데 배열인 척 하는 것을 유사 배열 객체라고 부른다.</li> <li>유사 배열 객체가 되기 위한 조건
<ul><li>반드시 <b><code>length</code> 프로퍼티</b>를 갖고 있어야 한다.</li> <li>가급적이면 index 번호가 0번부터 시작해서 1씩 증가해야 한다. 만약 이를 지키지 않게되면 예상치 못한 결과가 생긴다.</li> <li>그리고 객체에 선언한 키-값 쌍의 개수 만큼 <code>length</code> 프로퍼티의 값으로 지정해주는 것이 좋다.</li></ul></li></ul> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token comment">// 유사 배열 객체 예시</span>
<span class="token keyword">const</span> arrayLike <span class="token operator">=</span> <span class="token punctuation">{</span>
  <span class="token number">0</span><span class="token operator">:</span> <span class="token number">1</span><span class="token punctuation">,</span>
  <span class="token number">1</span><span class="token operator">:</span> <span class="token number">2</span><span class="token punctuation">,</span>
  <span class="token number">2</span><span class="token operator">:</span> <span class="token number">3</span><span class="token punctuation">,</span>
  <span class="token literal-property property">length</span><span class="token operator">:</span> <span class="token number">3</span><span class="token punctuation">,</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token comment">// 유사 배열 객체는 length 프로퍼티를 갖기 때문에 for 문으로 순회할 수 있다.</span>
<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> index <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> index <span class="token operator">&lt;</span> arrayLike<span class="token punctuation">.</span>length<span class="token punctuation">;</span> index <span class="token operator">+=</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>arrayLike<span class="token punctuation">[</span>index<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 1 2 3</span>
<span class="token punctuation">}</span>
</code></pre></div><div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token comment">// index 번호가 0번부터 시작해서 1씩 증가하지 않은 경우</span>
<span class="token keyword">const</span> arrayLike <span class="token operator">=</span> <span class="token punctuation">{</span>
  <span class="token number">0</span><span class="token operator">:</span> <span class="token number">1</span><span class="token punctuation">,</span>
  <span class="token number">2</span><span class="token operator">:</span> <span class="token number">2</span><span class="token punctuation">,</span>
  <span class="token number">3</span><span class="token operator">:</span> <span class="token number">3</span><span class="token punctuation">,</span>
  <span class="token literal-property property">length</span><span class="token operator">:</span> <span class="token number">3</span><span class="token punctuation">,</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> index <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> index <span class="token operator">&lt;</span> arrayLike<span class="token punctuation">.</span>length<span class="token punctuation">;</span> index <span class="token operator">+=</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>arrayLike<span class="token punctuation">[</span>index<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 1 undefined 3</span>
<span class="token punctuation">}</span>

console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>arrayLike<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// {0: 1, 2: 2, 3: 3, length: 3}</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>Array<span class="token punctuation">.</span><span class="token function">from</span><span class="token punctuation">(</span>arrayLike<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// [1, undefined, 2]</span>
</code></pre></div><div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token comment">// length 프로퍼티가 객체에 선언한 키-값 쌍의 개수보다 적은 경우</span>
<span class="token keyword">const</span> arrayLike <span class="token operator">=</span> <span class="token punctuation">{</span>
  <span class="token number">0</span><span class="token operator">:</span> <span class="token number">1</span><span class="token punctuation">,</span>
  <span class="token number">1</span><span class="token operator">:</span> <span class="token number">2</span><span class="token punctuation">,</span>
  <span class="token number">2</span><span class="token operator">:</span> <span class="token number">3</span><span class="token punctuation">,</span>
  length<span class="token operator">:</span> <span class="token number">1</span><span class="token punctuation">,</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>Array<span class="token punctuation">.</span><span class="token function">from</span><span class="token punctuation">(</span>arrayLike<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// [1]</span>
</code></pre></div><ul><li>일반적으로 유사 배열 객체는 이터러블이 아닌 일반 객체이므로 <code>Symbol.iterator</code> 메서드가 없어 <code>for ... of</code> 문으로 순회할 수 없다.</li></ul> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token keyword">const</span> arrayLike <span class="token operator">=</span> <span class="token punctuation">{</span>
  <span class="token number">0</span><span class="token operator">:</span> <span class="token number">1</span><span class="token punctuation">,</span>
  <span class="token number">1</span><span class="token operator">:</span> <span class="token number">2</span><span class="token punctuation">,</span>
  <span class="token number">2</span><span class="token operator">:</span> <span class="token number">3</span><span class="token punctuation">,</span>
  <span class="token literal-property property">length</span><span class="token operator">:</span> <span class="token number">3</span><span class="token punctuation">,</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">const</span> item <span class="token keyword">of</span> arrayLike<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>item<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// Uncaught TypeError: arrayLike is not iterable</span>
<span class="token punctuation">}</span>
</code></pre></div><ul><li>단, <code>arguments</code>, <code>NodeList</code>, <code>HTMLCollection</code> 은 유사 배열 객체이면서 이터러블이다.
<ul><li>왜냐하면 이 객체에 <code>Symbol.iterator</code> 메서드를 구현되어 있기 때문이다.</li> <li>또한 이터러블이 된 이후에도 <code>length</code> 프로퍼티를 가지며 인덱스로 접근할 수 있는 것에는 변함이 없어 이들은 유사 배열 객체이면서 이터러블인 것이다.</li></ul></li> <li>모든 유사 배열 객체가 이터러블인 것은 아니기 때문에 이를 해결하기 위해 ES6에서 <code>Array.from()</code> 메서드가 등장했다.
<ul><li>이는 유사 배열 객체를 진짜 배열로 변환(<code>Symbol.iterator</code> 메서드도 있음해주는데 자세한 내용은 <a href="https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/Array/from" target="_blank" rel="noopener noreferrer">MDN 공식 문서<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>를 통해 살펴보자.</li></ul></li></ul> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token keyword">const</span> arrayLike <span class="token operator">=</span> <span class="token punctuation">{</span>
  <span class="token number">0</span><span class="token operator">:</span> <span class="token number">1</span><span class="token punctuation">,</span>
  <span class="token number">1</span><span class="token operator">:</span> <span class="token number">2</span><span class="token punctuation">,</span>
  <span class="token number">2</span><span class="token operator">:</span> <span class="token number">3</span><span class="token punctuation">,</span>
  <span class="token literal-property property">length</span><span class="token operator">:</span> <span class="token number">3</span><span class="token punctuation">,</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">const</span> arr <span class="token operator">=</span> Array<span class="token punctuation">.</span><span class="token function">from</span><span class="token punctuation">(</span>arrayLike<span class="token punctuation">)</span><span class="token punctuation">;</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>arr<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// [1, 2, 3]</span>

<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">const</span> item <span class="token keyword">of</span> arr<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>item<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 1 2 3</span>
<span class="token punctuation">}</span>
</code></pre></div><hr> <br> <h3 id="_3-값에-의한-전달"><a href="#_3-값에-의한-전달" class="header-anchor">#</a> (3) 값에 의한 전달</h3> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token keyword">var</span> score <span class="token operator">=</span> <span class="token number">80</span><span class="token punctuation">;</span>

<span class="token keyword">var</span> copy <span class="token operator">=</span> score<span class="token punctuation">;</span>

<span class="token comment">// 변수에 원시 값을 갖는 변수를 할당하면 할당받는 변수(copy)에는 할당되는 변수(score)의 원시 값이 복사되어 전달되는데 이를 '값에 의한 전달'이라 한다.</span>
<span class="token comment">// 하지만 score, copy 변수는 숫자 값 80을 갖지만 두 변수의 값 80은 서로 다른 메모리 공간에 저장된 별개의 값이다.</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>score<span class="token punctuation">,</span> copy<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 80 80</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>score <span class="token operator">===</span> copy<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// true</span>

<span class="token comment">// 두 변수의 값은 다른 메모리 공간에 저장된 별개의 값이므로 score 변수의 값을 변경해도 copy 변수의 값에는 어떠한 영향도 없다.</span>
score <span class="token operator">=</span> <span class="token number">100</span><span class="token punctuation">;</span>

console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>score<span class="token punctuation">,</span> copy<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 100 80</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>score <span class="token operator">===</span> copy<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// false</span>
</code></pre></div><ul><li>'값에 의한 전달'을 엄격하게 표현하면 변수에는 값이 전달되는 것이 아니라 <b>메모리 주소가 전달</b>되는데 변수와 같은 식별자는 값이 아니라 메모리 주소를 기억하고 있기 때문이다.
<ul><li>단, 전달된 메모리 주소를 통해 메모리 공간에 접근하면 값을 참조할 수 있다.</li> <li>변수를 할당하거나 두 변수 중 어느 하나의 변수에 값을 재할당할 때 두 변수의 원시 값은 <b>서로 다른 메모리 공간에 저장된 별개의 값이 되어 어느 한쪽에서 재할당을 통해 값을 변경하더라도 서로 간섭할 수 없다.</b></li></ul></li> <li>'Chapter04. 변수'에서 살펴보았던 '식별자' 내용을 다시 살펴보자.
<ul><li>식별자는 어떤 값을 구별해서 식별할 수 있는 고유한 이름이라고 했다.</li> <li>값은 메모리 공간에 저장되어 있어 메모리 공간에 저장되어 있는 어떤 값을 구별해서 식별해낼 수 있어야 하므로 값 자체를 기억하는 것이 아니라 해당 값에 저장되어 있는 <b>메모리 주소를 기억</b>한다.</li></ul></li></ul> <br> <h2 id="_2-객체"><a href="#_2-객체" class="header-anchor">#</a> 2. 객체</h2> <h3 id="_1-자바스크립트-객체의-관리-방식"><a href="#_1-자바스크립트-객체의-관리-방식" class="header-anchor">#</a> (1) 자바스크립트 객체의 관리 방식</h3> <ul><li>자바스크립트 객체는 프로퍼티 키를 인덱스로 하는 <b>해시 테이블(hash table)</b>이라고 생각할 수 있다.
<ul><li>대부분의 자바스크립트 엔진은 해시 테이블과 유사하지만 높은 성능을 위해 일반적인 해시 테이블보다 나은 방법으로 객체를 구현한다.</li></ul></li> <li>자바스크립트는 자바, C++ 언어와 달리 클래스 없이 객체를 생성할 수 있으며 객체가 생성된 이후라도 동적으로 프로퍼티와 메서드를 추가할 수 있따.
<ul><li>이는 사용하기 매우 편리하지만 성능 면에서는 이론적으로 클래스 기반 객체지향 프로그래밍 언어의 객체보다 생성과 프로퍼티 접근에 비용이 더 많이 드는 비효율적인 방식이다.</li></ul></li> <li>따라서 V8 자바스크립트 엔진에서는 프로퍼티에 접근하기 위해 동적 탐색대신 <b>히든 클래스(hidden class)</b>라는 방식을 사용해 성능을 보장한다.</li></ul> <br> <h3 id="_2-자바스크립트의-히든-클래스-hidden-class"><a href="#_2-자바스크립트의-히든-클래스-hidden-class" class="header-anchor">#</a> (2) 자바스크립트의 히든 클래스(hidden class)</h3> <h4 id="동적-탐색-dynamic-lookup"><a href="#동적-탐색-dynamic-lookup" class="header-anchor">#</a> 📍 동적 탐색(dynamic lookup)</h4> <ul><li><p>자바스크립트는 동적 타이핑 언어로 코드를 실행할 때의 <u>상황에 따라 데이터 타입이 정해진다.</u></p> <ul><li>그러다보니 객체의 프로퍼티에 접근하는 속도 면에서는 정적 타이핑 언어의 코드와 비교했을 때 불리해질 수 있다.</li></ul></li> <li><p>정적 타이핑 언어에서는 가변길이 배열과 같이 동적인 데이터 타입을 사용하여 프로퍼티의 메모리 오프셋을 컴파일 시에 결정할 수 있찌만 동적 타이핑 언어에서는 프로퍼티를 선언했을 때의 프로퍼티의 데이터 타입이나 순서가 실제로 프로퍼티 값을 접근할 때 달라질 수 있어 프로퍼티의 메모리 오프셋을 컴파일할 때 결정하는 것은 불가능하다.</p> <ul><li>참고로 여기서 오프셋이란 메모리 주소를 탐색할 때 기준 주소에서 얼만큼 떨어져 있는지 나타내는 주소를 가리킬 때 쓰인다.</li></ul></li> <li><p>이로 인해 동적 타이핑 언어인 자바스크립트에서는 <b>동적 탐색(dynamic lookup)</b>으로 프로퍼티 값을 읽어야 한다.</p></li> <li><p>정적 타이핑 언어와 동적 타이핑 언어의 차이</p> <p><img src="https://user-images.githubusercontent.com/52685250/152634284-36fda41c-ada0-440c-9268-498507139202.png" alt="hiddenclass"></p> <ul><li>정적 타이핑 언어(왼쪽)는 오프셋 값만으로도 모든 멤버 변수에 접근할 수 있지만, 동적 타이핑 언어(오른쪽)는 수행 중간에 필드 구조가 변경될 수 있으므로 기본적으로 프로퍼티와 값 세트를 모든 객체가 들고 있어야 한다.</li> <li>동적 타이핑 언어는 언제 프로퍼티와 값이 바뀔 지 모르므로 계속해서 모든 테이블을 들고 다녀야 한다.</li> <li>이로 인해 중복된 데이터로 인한 메모리적인 측면 뿐만 아니라 성능까지도 문제가 생길 수 밖에 없다.</li></ul></li></ul> <br> <h4 id="v8-자바스크립트-엔진에서-동적-탐색을-회피하는-방법-히든-클래스-hidden-class"><a href="#v8-자바스크립트-엔진에서-동적-탐색을-회피하는-방법-히든-클래스-hidden-class" class="header-anchor">#</a> 📍 V8 자바스크립트 엔진에서 동적 탐색을 회피하는 방법 - 히든 클래스(hidden class)</h4> <blockquote><p>V8은 히든 클래스를 이용하여 동적 탐색(Dynamic Lookup)을 회피하고 있다.</p> <p>한마디로 말하자면, 프로퍼티가 바뀔 때 각각 그 프로퍼티의 오프셋을 업데이트한 뒤 그 값을 가지고 있는 방식이다.</p></blockquote> <h5 id="hidden-class-특징"><a href="#hidden-class-특징" class="header-anchor">#</a> 💡 hidden class 특징</h5> <ul><li>반드시 하나의 객체마다 부여된다.</li> <li>각 프로퍼티에 대해 <b>오프셋 정보</b>를 가지고 있다.</li> <li>객체에 프로퍼티가 <b>추가, 수정, 삭제되면 새로운 hidden class</b>가 만들어지며, 이는 기존 hidden class 정보에 추가로 업데이트된 정보를 가지고 있게 된다.</li> <li>위 과정에서 원래의 hidden class는 참조해야되는 hidden class 정보(<b>전환정보</b>)가 추가된다.</li></ul> <br> <h5 id="hidden-class-동작-방식"><a href="#hidden-class-동작-방식" class="header-anchor">#</a> 💡 hidden class 동작 방식</h5> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token comment">// STEP 1</span>

<span class="token keyword">var</span> obj <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre></div><ul><li>우선 아무것도 없는 빈 객체를 생성하자.</li> <li>객체를 생성하면 무조건 히든 클래스(이 단계의 히든 클래스르 <code>C0</code> 이라고 하자.)가 생성되고 이 객체가 <code>C0</code> 히든 클래스를 참조하게 된다.</li> <li>이 때 <code>obj</code> 객체가 프로퍼티를 갖고 있지 않으므로 히든 클래스에는 아직 아무런 정보도 없는 상태이다.</li></ul> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token comment">// STEP 2</span>

<span class="token keyword">var</span> obj <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
obj<span class="token punctuation">.</span>x <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
</code></pre></div><ul><li>위와 같이 객체를 생성한 후 <code>obj.x</code> 프로퍼티에 값을 대입해보자.</li> <li>객체에 프로퍼티를 추가했으므로 새로운 히든 클래스 <code>C1</code>이 생성되고 <code>x</code> 프로퍼티에 대한 오프셋 값을 갖는다.</li> <li><code>obj</code> 객체는 원래 <code>C0</code> 히든 클래스를 참조했었는데 새로운 프로퍼티가 생겼으므로 <code>C1</code> 히든 클래스를 참조하게 된다.</li> <li>그리고 중요한 포인트는 <code>x</code> 프로퍼티를 추가하면 참조하는 히든 클래스가 <code>C1</code>으로 전환(transition)된다는 정보가 <code>C0</code> 클래스에 추가된다.</li></ul> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token comment">// STEP 3</span>

<span class="token keyword">var</span> obj <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
obj<span class="token punctuation">.</span>x <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
obj<span class="token punctuation">.</span>y <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span>
</code></pre></div><ul><li>이번에는 <code>obj.y</code> 프로퍼티에 값을 대입해보자.</li> <li>이때도 새로운 프로퍼티가 추가되므로 히든 클래스 <code>C2</code> 가 생성되고 <code>y</code> 프로퍼티에 대한 오프셋 값을 <code>C2</code>에서 가지게 된다.</li> <li>그리고 <code>obj</code> 객체에 대응하는 히든 클래스가 <code>C1</code>에서 <code>C2</code>로 바뀐다. (<u><code>C1</code> 히든 클래스에 <code>y</code> 프로퍼티의 오프셋 값을 추가하는 것이 아님!</u>)</li> <li>마찬가지로 <code>C1</code> 히든 클래스에는 <code>y</code> 프로퍼티를 추가하면 참조하는 히든 클래스가 <code>C2</code>로 전환된다는 정보가 추가된다.</li></ul> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token comment">// STEP 4</span>

<span class="token keyword">var</span> obj <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
obj<span class="token punctuation">.</span>x <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
obj<span class="token punctuation">.</span>y <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>obj<span class="token punctuation">.</span>y<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><ul><li>만약 위와 같이 <code>obj.y</code> 프로퍼티에 접근한다면 내부적으로 어떻게 동작하게 될까?</li> <li><code>obj</code> 객체와 연결되어 있는 히든 클래스는 <code>C2</code>가 되며 여기에 적혀 있는 <code>y</code> 프로퍼티의 오프셋을 이용해서 <code>y</code>의 값을 참조하게 된다.</li> <li>이것이 바로 V8이 사용하는 동적 탐색을 회피하는 히든 클래스 방식이다.</li></ul> <br> <h5 id="hidden-class의-효율을-높여주는-전환-정보"><a href="#hidden-class의-효율을-높여주는-전환-정보" class="header-anchor">#</a> 💡 hidden class의 효율을 높여주는 전환 정보</h5> <ul><li>위 내용에서 '전환 정보'라는 용어가 등장했다.</li> <li>중간에 객체의 필드 구조가 변한다면 이 테이블을 참조하여 객체가 다른 히든 클래스로 옮겨가거나 혹은 새로 생성하게 된다.</li></ul> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token keyword">function</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token parameter">value</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span>x <span class="token operator">=</span> value<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">var</span> a <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">foo</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// (a)</span>
<span class="token keyword">var</span> b <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">foo</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// (b)</span>
</code></pre></div><ul><li>위 코드에서 (a) 부분이 실행되는 시점에서는 다음과 같은 정보가 존재하며 <code>a</code> 객체는 <code>C1</code> 히든 클래스를 참조하고 있는 상태다.
<ul><li>히든 클래스 <code>C0</code> <ul><li>프로퍼티의 오프셋 값 없음</li> <li><code>x</code> 프로퍼티를 추가하면 참조하는 히든 클래가 <code>C1</code> 으로 전환된다. =&gt; <b><u>전환정보</u></b></li></ul></li> <li>히든 클래스 <code>C1</code> <ul><li><code>x</code> 프로퍼티의 오프셋 값</li></ul></li></ul></li> <li>이어서 (b) 부분에서 <code>b</code> 객체가 생성되는데 이 과정에서 <code>b</code> 객체가 <code>C0</code> 클래스를 참조했을 때 위에서 살펴본 전환정보가 존재하므로 이로 인해 <code>x</code> 프로퍼티를 추가할 때 새로운 히든 클래스를 생성하지 않고 <code>C1</code> 클래스를 참조하여 자기 자신과 <code>C1</code> 클래스를 연결시킨다.</li> <li>이렇게 해서 히든 클래스를 쓸데 없이 늘리지 않으면서 오프셋을 효율적으로 관리하는 목적을 달성한다.</li></ul> <br> <h5 id="inline-caching"><a href="#inline-caching" class="header-anchor">#</a> 💡 Inline Caching</h5> <ul><li><p>Inline Caching의 기본 개념</p> <ul><li>V8 엔진의 최적화 포인트는 최소한의 hidden class를 만드는 것이다.</li> <li>메모리 소모는 줄일지언정, 프로퍼티를 변경할 때마다 hidden class가 생성된다.</li> <li>이를 방지하기 위해 <b>Inline Caching</b> 기법을 사용한다.</li> <li>객체 필드에 접근할 때 hidden class를 사용하는데 이 때 우리가 얻고 싶은 것은 필드의 오프셋 값이다.
<ul><li>Inline Caching을 통해서 이 <b>오프셋 값을 캐싱</b>한다는 의미이다.</li></ul></li> <li>자바스크립트 엔진에서 Inline Caching의 전제 조건
<ul><li>동적인 언어라고 해봤자 실제로는 안바뀌는데 더 많다.</li> <li>성능을 빠르게 하려면 딴 거 다 필요없고 <b>루프</b>를 돌려라.</li></ul></li> <li>즉, hidden class가 있다고 해도 유지 중인 오프셋을 사용하여 메모리를 참조하는 작업은 여전히 남아있는데, 이 작업이 <b>같은 조건 하에 여러 번 반복</b>될 때 그 결과를 캐싱해서 전달하자는 것이 Inline Caching의 핵심이다.</li></ul></li> <li><p>Inline Caching의 적용 사례</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">var</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">10</span><span class="token punctuation">;</span> i <span class="token operator">+=</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>x <span class="token operator">=</span> i<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><ul><li><p>위 코드에서 <code>.x</code> 부분이 Inline Caching이 일어나는데 자세히 살펴보자.</p></li> <li><p>우선 <code>i = 0</code> 일 때는 캐싱된 값이 없으므로 <code>arr[0]</code>의 내부 구조와 <code>arr[0].x</code> 오프셋 값이 캐싱될 준비를 마친다.</p></li> <li><p>그 후 두 번째(<code>i = 1</code>)부터 마지막(<code>i = 9</code>)까지는 캐싱된 오프셋 값을 바로 쓸 수 있게된다.</p> <ul><li>정확하게는 두 번째 수행부터 캐싱하게 된다.</li></ul></li> <li><p>단, <code>arr[1]</code> 부터 <code>arr[9]</code>까지 <b>모두 같은 필드 구조를 가지고 있어야만 성립이 된다.</b></p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token keyword">const</span> arr <span class="token operator">=</span> <span class="token punctuation">[</span>
  <span class="token punctuation">{</span>
    <span class="token literal-property property">x</span><span class="token operator">:</span> <span class="token number">1</span><span class="token punctuation">,</span>
    <span class="token literal-property property">y</span><span class="token operator">:</span> <span class="token number">2</span><span class="token punctuation">,</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span>
  <span class="token punctuation">{</span>
    <span class="token literal-property property">x</span><span class="token operator">:</span> <span class="token number">3</span><span class="token punctuation">,</span>
    <span class="token literal-property property">y</span><span class="token operator">:</span> <span class="token number">4</span><span class="token punctuation">,</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span>
<span class="token punctuation">]</span><span class="token punctuation">;</span>
</code></pre></div><ul><li>다른 객체가 이것저것 섞여 있던가 <code>x</code> 프로퍼티가 없어 새롭게 추가해야하는 상황이라면 이런 경우에는 Inline Caching의 혜택을 받지 못하여 오히려 손해를 보게 된다.</li> <li>즉, 위 예시 <code>arr</code>  처럼 동일한 필드 구조를 가지고 있어야 한다.</li></ul></li></ul></li> <li><p>추가로 자바스크립트 엔진에서는 다양한 방식으로 최적화를 이뤄가고 있는데 <a href="https://meetup.toast.com/posts/77" target="_blank" rel="noopener noreferrer">자바스크립트 엔진의 최적화 기법 (1) - JITC, Adaptive Compilation<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a> 게시글을 통해서 자세한 내용을 파악하는 시간을 가져보는 것도 좋을 것 같다.</p> <ul><li>만약 시간이 없다면 이 게시글에서 '4. Adaptive JIT Compilation', '5. 결론' 단락 부분만 읽어도 좋다.</li> <li>특히 마지막에 나와 있는 것처럼 성능이 좋은 자바스크립트 코드를 만들고 싶다면 정적 타이핑 언어처럼 코드를 작성하는 것이 좋다는 것에 주목하자.</li> <li><code>number</code> 타입이면 <code>number</code>에 맞게 <code>string</code> 타입이면 <code>string</code> 타입으로 고정하여 코드를 작성하는 것이 성능적인 측면에서도 좋다. (특히 array!)</li></ul></li></ul> <br> <h4 id="reference"><a href="#reference" class="header-anchor">#</a> 📍 Reference</h4> <ul><li><a href="https://meetup.toast.com/posts/78" target="_blank" rel="noopener noreferrer">자바스크립트 엔진의 최적화 기법 (2) - Hidden class, Inline Caching<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li> <li><a href="https://engineering.linecorp.com/ko/blog/v8-hidden-class/" target="_blank" rel="noopener noreferrer">V8의 히든 클래스 이야기<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li> <li><a href="https://crmrelease.tistory.com/79" target="_blank" rel="noopener noreferrer">[개념정리] 자바스크립트 엔진 v8이 사용하는 Hidden Class, Inline Cacahing<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li></ul> <br> <h3 id="_3-변경-가능한-값"><a href="#_3-변경-가능한-값" class="header-anchor">#</a> (3) 변경 가능한 값</h3> <ul><li>원시 값을 할당한 변수를 참조하면 메모리에 저장되어 있는 원시 값에 접근한다.</li> <li>하지만 객체를 할당한 변수를 참조하면 메모리에 저장되어 있는 <b>참조 값(reference value)</b>을 통해 실제 객체에 접근한다.</li> <li>객체의 할당 과정</li></ul> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token keyword">var</span> user <span class="token operator">=</span> <span class="token punctuation">{</span>
  <span class="token literal-property property">name</span><span class="token operator">:</span> <span class="token string">'wally'</span><span class="token punctuation">,</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>user<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// {name: &quot;wally&quot;}</span>
</code></pre></div><img src="https://user-images.githubusercontent.com/52685250/152636680-60cae743-f82b-41b8-b7c8-e9fe010c6873.JPG" width="600"> <ul><li>변경 가능한 객체
<ul><li>원시 값과 다르게 객체는 재할당 없이 객체를 직접 변경할 수 있다.</li> <li>아래 예시 코드와 같이 프로퍼티를 동적으로 추가할 수도 있고 프로퍼티 값을 갱신할 수도 있으며 프로퍼티 자체를 삭제할 수도 있다.</li> <li>객체는 원시 값과 달리 변수에 재할당을 하지 않았으므로 객체를 할당한 변수의 참조 값을 아래 그림과 같이 변경되지 않는다.</li></ul></li></ul> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token keyword">var</span> user <span class="token operator">=</span> <span class="token punctuation">{</span>
  <span class="token literal-property property">name</span><span class="token operator">:</span> <span class="token string">'wally'</span><span class="token punctuation">,</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token comment">// 프로퍼티 값 갱신</span>
user<span class="token punctuation">.</span>name <span class="token operator">=</span> <span class="token string">'wallywally'</span><span class="token punctuation">;</span>

<span class="token comment">// 프로퍼티 동적 생성</span>
user<span class="token punctuation">.</span>zipCode <span class="token operator">=</span> <span class="token number">12345</span><span class="token punctuation">;</span>

console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>user<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// {name: &quot;wallywally&quot;, zipCode: 12345}</span>
</code></pre></div><img src="https://user-images.githubusercontent.com/52685250/152636758-ee1a101e-c750-45c7-8423-75ae57ba12fc.JPG" width="600"> <ul><li><p>객체 복사시 trade off</p> <ul><li>객체를 생성하고 관리하는 방식은 매우 복잡하며 비용이 많이 드는 일이다.</li> <li>객체를 변경할 때마다 원시 값처럼 이전 값을 복사해서 새롭게 생성한다면 명확하고 신뢰성이 확보되겠지만 객체는 크기가 매우 클 수도 있고, 원시 값처럼 크기가 일정하지도 않으며, 프로퍼티 값이 객체일 수도 있어 복사해서 생성하는 비용이 많이 든다.</li> <li>따라서 메모리를 효율적으로 사용하기 위해, 그리고 객체를 복사해 생성하는 비용을 절약하여 성능을 향상시키기 위해 객체는 변경 가능한 값으로 설계되어 있다.</li> <li>메모리 사용의 효용성과 성능을 위해 어느 정도의 구조적인 단점을 감안한 설계라고 할 수 있다.</li></ul></li> <li><p>객체의 얕은 복사(shallow copy) vs 깊은 복사(deep copy)</p> <ul><li><p>얕은 복사(shallow copy)는 객체의 <b>한 단계까지만 복사</b>하는 것을 말하고 깊은 복사(deep copy)는 객체에 <b>중첩되어 있는 객체까지 모두 복사</b>하는 것을 말한다.</p> <ul><li>얕은 복사와 깊은 복사로 생성된 객체는 원본과는 다른 객체다.
<ul><li>즉, 원본과 복사본은 참조 값이 다른 별개의 객체다.</li></ul></li></ul></li> <li><p>하지만 얕은 복사는 객체에 중첩되어 있는 객체의 경우 <b>참조 값을 복사</b>하고 깊은 복사는 객체에 중첩되어 있는 객체까지 <b>모두 복사해서 원시 값처럼 완전한 복사본을 만든다</b>는 차이가 있다.</p></li></ul></li></ul> <hr> <h3 id="객체의-얕은-복사-shallow-copy-방법"><a href="#객체의-얕은-복사-shallow-copy-방법" class="header-anchor">#</a> ➕ 객체의 얕은 복사(shallow copy) 방법</h3> <h4 id="object-assign-메서드-mdn-공식-문서"><a href="#object-assign-메서드-mdn-공식-문서" class="header-anchor">#</a> 📍 <code>Object.assign()</code> 메서드 - <a href="https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/Object/assign" target="_blank" rel="noopener noreferrer">MDN 공식 문서<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></h4> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token keyword">const</span> obj <span class="token operator">=</span> <span class="token punctuation">{</span>
  <span class="token literal-property property">x</span><span class="token operator">:</span> <span class="token number">1</span><span class="token punctuation">,</span>
  <span class="token literal-property property">y</span><span class="token operator">:</span> <span class="token punctuation">{</span>
    <span class="token literal-property property">z</span><span class="token operator">:</span> <span class="token number">2</span><span class="token punctuation">,</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">const</span> newObj <span class="token operator">=</span> Object<span class="token punctuation">.</span><span class="token function">assign</span><span class="token punctuation">(</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">,</span> obj<span class="token punctuation">)</span><span class="token punctuation">;</span>

newObj<span class="token punctuation">.</span>x <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
newObj<span class="token punctuation">.</span>y<span class="token punctuation">.</span>z <span class="token operator">=</span> <span class="token number">3</span><span class="token punctuation">;</span>

console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>obj<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// {x: 1, y: {z: 3}}</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>newObj<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// {x: 0, y: {z: 3}}</span>
</code></pre></div><br> <h4 id="전개-연산자-spread-operator-mdn-공식-문서"><a href="#전개-연산자-spread-operator-mdn-공식-문서" class="header-anchor">#</a> 📍 전개 연산자(Spread Operator) - <a href="https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Operators/Spread_syntax" target="_blank" rel="noopener noreferrer">MDN 공식 문서<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></h4> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token keyword">const</span> obj <span class="token operator">=</span> <span class="token punctuation">{</span>
  <span class="token literal-property property">x</span><span class="token operator">:</span> <span class="token number">1</span><span class="token punctuation">,</span>
  <span class="token literal-property property">y</span><span class="token operator">:</span> <span class="token punctuation">{</span>
    <span class="token literal-property property">z</span><span class="token operator">:</span> <span class="token number">2</span><span class="token punctuation">,</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">const</span> newObj <span class="token operator">=</span> <span class="token punctuation">{</span> <span class="token operator">...</span>obj <span class="token punctuation">}</span><span class="token punctuation">;</span>

newObj<span class="token punctuation">.</span>x <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
newObj<span class="token punctuation">.</span>y<span class="token punctuation">.</span>z <span class="token operator">=</span> <span class="token number">3</span><span class="token punctuation">;</span>

console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>obj<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// {x: 1, y: {z: 3}}</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>newObj<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// {x: 0, y: {z: 3}}</span>
</code></pre></div><br> <h3 id="객체의-깊은-복사-deep-copy-방법"><a href="#객체의-깊은-복사-deep-copy-방법" class="header-anchor">#</a> ➕ 객체의 깊은 복사(deep copy) 방법</h3> <h4 id="json-객체-메소드-이용-json-stringify-mdn-공식-문서-json-parse-mdn-공식-문서"><a href="#json-객체-메소드-이용-json-stringify-mdn-공식-문서-json-parse-mdn-공식-문서" class="header-anchor">#</a> 📍 JSON 객체 메소드 이용 - <code>JSON.stringify()</code> - <a href="https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/JSON/stringify" target="_blank" rel="noopener noreferrer">MDN 공식 문서<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>, <code>JSON.parse()</code> - <a href="https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/JSON/parse" target="_blank" rel="noopener noreferrer">MDN 공식 문서<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></h4> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token keyword">const</span> obj <span class="token operator">=</span> <span class="token punctuation">{</span>
  <span class="token literal-property property">x</span><span class="token operator">:</span> <span class="token number">1</span><span class="token punctuation">,</span>
  <span class="token literal-property property">y</span><span class="token operator">:</span> <span class="token punctuation">{</span>
    <span class="token literal-property property">z</span><span class="token operator">:</span> <span class="token number">2</span><span class="token punctuation">,</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">const</span> newObj <span class="token operator">=</span> <span class="token constant">JSON</span><span class="token punctuation">.</span><span class="token function">parse</span><span class="token punctuation">(</span><span class="token constant">JSON</span><span class="token punctuation">.</span><span class="token function">stringify</span><span class="token punctuation">(</span>obj<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

newObj<span class="token punctuation">.</span>x <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
newObj<span class="token punctuation">.</span>y<span class="token punctuation">.</span>z <span class="token operator">=</span> <span class="token number">3</span><span class="token punctuation">;</span>

console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>obj<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// {x: 1, y: {z: 2}}</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>newObj<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// {x: 0, y: {z: 3}}</span>
</code></pre></div><ul><li>하지만 이 방법은 치명적인 단점 두 가지가 있다.
<ul><li>다른 방법에 비해 성능이 느리다.</li> <li><code>JSON.stringify()</code> 메서드는 함수를 만났을 때 <code>undefined</code>로 처리한다.</li></ul></li></ul> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token keyword">const</span> obj <span class="token operator">=</span> <span class="token punctuation">{</span>
  <span class="token literal-property property">x</span><span class="token operator">:</span> <span class="token number">1</span><span class="token punctuation">,</span>
  <span class="token literal-property property">y</span><span class="token operator">:</span> <span class="token punctuation">{</span>
    <span class="token literal-property property">z</span><span class="token operator">:</span> <span class="token number">2</span><span class="token punctuation">,</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span>
  <span class="token function-variable function">f1</span><span class="token operator">:</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>x<span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">const</span> newObj <span class="token operator">=</span> <span class="token constant">JSON</span><span class="token punctuation">.</span><span class="token function">parse</span><span class="token punctuation">(</span><span class="token constant">JSON</span><span class="token punctuation">.</span><span class="token function">stringify</span><span class="token punctuation">(</span>obj<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>newObj<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// {x: 1, y: {z: 2}}</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>newObj<span class="token punctuation">.</span>f1<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// undefined</span>
</code></pre></div><br> <h4 id="lodash-라이브러리의-clonedeep-메서드-공식-문서-4-17-15-버전"><a href="#lodash-라이브러리의-clonedeep-메서드-공식-문서-4-17-15-버전" class="header-anchor">#</a> 📍 lodash 라이브러리의 <code>cloneDeep()</code> 메서드 - <a href="https://lodash.com/docs/4.17.15#cloneDeep" target="_blank" rel="noopener noreferrer">공식 문서(4.17.15 버전)<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></h4> <blockquote><p>참고로 커스텀 재귀 함수로 구현할 수 있지만 많은 개발자들에 의해 검증되어 있고 오래동안 쓰여온 lodash의 <code>cloneDeep()</code> 메서드 사용하는 것을 권장한다.</p></blockquote> <div class="language-bash extra-class"><pre class="language-bash"><code><span class="token function">npm</span> i lodash
</code></pre></div><div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token comment">// tree shaking 기법을 이용해서 lodash의 메서드 중 사용할 메서드만 가져오는 방식</span>
<span class="token keyword">import</span> cloneDeep <span class="token keyword">from</span> <span class="token string">'lodash/cloneDeep'</span><span class="token punctuation">;</span>

<span class="token keyword">const</span> obj <span class="token operator">=</span> <span class="token punctuation">{</span>
  <span class="token literal-property property">x</span><span class="token operator">:</span> <span class="token number">1</span><span class="token punctuation">,</span>
  <span class="token literal-property property">y</span><span class="token operator">:</span> <span class="token punctuation">{</span>
    <span class="token literal-property property">z</span><span class="token operator">:</span> <span class="token number">2</span><span class="token punctuation">,</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span>
  <span class="token function-variable function">f1</span><span class="token operator">:</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>x<span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">const</span> newObj <span class="token operator">=</span> <span class="token function">cloneDeep</span><span class="token punctuation">(</span>obj<span class="token punctuation">)</span><span class="token punctuation">;</span>

newObj<span class="token punctuation">.</span>x <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
newObj<span class="token punctuation">.</span>y<span class="token punctuation">.</span>z <span class="token operator">=</span> <span class="token number">3</span><span class="token punctuation">;</span>

console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>obj<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// {x: 1, y: {z: 2}, f1: f()}</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>obj<span class="token punctuation">.</span><span class="token function">f1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 1</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>newObj<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// {x: 0, y: {z: 3}, f1: f()}</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>newObj<span class="token punctuation">.</span><span class="token function">f1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 0</span>
</code></pre></div><br> <h3 id="_4-참조에-의한-전달"><a href="#_4-참조에-의한-전달" class="header-anchor">#</a> (4) 참조에 의한 전달</h3> <ul><li>자바스크립트의 객체는 원시 값과는 다르게 여러 개의 식별자가 하나의 객체를 공유할 수 있다.</li> <li>이로 인한 부작용이 존재하는데 이미 위에서 객체의 얕은 복사와 깊은 복사를 통해서 살펴보았지만 다시 한 번 더 정리해보자.</li></ul> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token keyword">var</span> user <span class="token operator">=</span> <span class="token punctuation">{</span>
  <span class="token literal-property property">name</span><span class="token operator">:</span> <span class="token string">'wally'</span><span class="token punctuation">,</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token comment">// 참조 값을 복사(얕은 복사)</span>
<span class="token keyword">var</span> copyUser <span class="token operator">=</span> user<span class="token punctuation">;</span>
</code></pre></div><ul><li>객체를 가리키는 변수(원본, <code>user</code>)를 다른 변수(사본, <code>copyUser</code>)에 할당하면 원본의 <b>참조 값이 복사되어 전달</b>되는데 이를 <b>참조에 의한 전달</b>이라 한다.</li></ul> <p><img src="https://user-images.githubusercontent.com/52685250/152638691-c9ef9494-3e8e-43ba-88ea-22aa9290b137.JPG" alt="참조에 의한 전달"></p> <ul><li>위 그림처럼 원본 <code>user</code>를 사본 <code>copyUser</code>에 할당하면 원본 <code>user</code>의 참조 값을 복사해서 <code>copyUser</code>에 저장한다.
<ul><li>이때 원본 <code>user</code>와 사본 <code>copyUser</code>는 저장된 메모리 주소는 다르지만 동일한 참조 값을 갖는다.</li> <li>다시 말해, 두 변수 모두 동일한 객체를 가리키며 이는 <b>두 개의 식별자가 하나의 객체를 공유</b>한다는 것을 의미한다.</li></ul></li> <li>이러한 특성으로 인해 어느 한 쪽에서 객체를 변경하면 서로 영향을 주고받는다.</li></ul> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token keyword">var</span> user <span class="token operator">=</span> <span class="token punctuation">{</span>
  <span class="token literal-property property">name</span><span class="token operator">:</span> <span class="token string">'wally'</span><span class="token punctuation">,</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">var</span> copyUser <span class="token operator">=</span> user<span class="token punctuation">;</span>

console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>user <span class="token operator">===</span> copyUser<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// true</span>

copyUser<span class="token punctuation">.</span>name <span class="token operator">=</span> <span class="token string">'wallywally'</span><span class="token punctuation">;</span>
copyUser<span class="token punctuation">.</span>zipCode <span class="token operator">=</span> <span class="token number">12345</span><span class="token punctuation">;</span>

console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>user<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// {name: &quot;wallywally&quot;, zipCode: 12345}</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>copyUser<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// {name: &quot;wallywally&quot;, zipCode: 12345}</span>
</code></pre></div><ul><li>결국 '값에 의한 전달'과 '참조에 의한 전달'은 식별자가 기억하는 <b>메모리 공간에 저장되어 있는 값을 복사해서 전달한다</b>는 면에서 동일하다.
<ul><li>다만 식별자가 기억하는 메모리 공간, 즉 변수에 저장되어 있는 값이 <b>원시 값이냐 참조 값이냐의 차이</b>만 있을 뿐이다.</li></ul></li></ul> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token keyword">var</span> user1 <span class="token operator">=</span> <span class="token punctuation">{</span>
  <span class="token literal-property property">name</span><span class="token operator">:</span> <span class="token string">'wally'</span><span class="token punctuation">,</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">var</span> user2 <span class="token operator">=</span> <span class="token punctuation">{</span>
  <span class="token literal-property property">name</span><span class="token operator">:</span> <span class="token string">'wally'</span><span class="token punctuation">,</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>user1 <span class="token operator">===</span> user2<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// (1)</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>user1<span class="token punctuation">.</span>name <span class="token operator">===</span> user2<span class="token punctuation">.</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// (2)</span>
</code></pre></div><table><thead><tr><th>문제</th> <th>결과</th> <th>이유</th></tr></thead> <tbody><tr><td>(1)</td> <td><code>false</code></td> <td><code>user1</code> 변수와 <code>user2</code> 변수가 가리키는 객체는 비록 내용은 같지만 다른 메모리에 저장된 별개의 객체이기 때문이다.</td></tr> <tr><td>(2)</td> <td><code>true</code></td> <td>프로퍼티 값을 참조하는 <code>user1.name</code>, <code>user2.name</code>은 값으로 평가될 수 있는 표현식이고 모두 원시 값 <code>'wally'</code>로 평가되기 때문이다.</td></tr></tbody></table></div> <footer class="page-edit"><!----> <!----></footer> <div class="page-nav"><p class="inner"><span class="prev">
      ←
      <a href="/wally-wally-til/til/js-deep-dive/chapter10.html" class="prev">
        Chapter10
      </a></span> <span class="next"><a href="/wally-wally-til/til/js-deep-dive/chapter12.html">
        Chapter12
      </a>
      →
    </span></p></div> </main></div><div class="global-ui"></div></div>
    <script src="/wally-wally-til/assets/js/app.f5246800.js" defer></script><script src="/wally-wally-til/assets/js/2.fd76ebd9.js" defer></script><script src="/wally-wally-til/assets/js/43.7be3d9b4.js" defer></script>
  </body>
</html>
