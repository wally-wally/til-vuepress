<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>📄 Item06 ~ 10 | wally-wally TIL</title>
    <meta name="generator" content="VuePress 1.9.7">
    
    <meta name="description" content="wally-wally&#39;s TIL">
    <meta name="theme-color" content="#3eaf7c">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black">
    
    <link rel="preload" href="/wally-wally-til/assets/css/0.styles.5b0b7f0f.css" as="style"><link rel="preload" href="/wally-wally-til/assets/js/app.f5246800.js" as="script"><link rel="preload" href="/wally-wally-til/assets/js/2.fd76ebd9.js" as="script"><link rel="preload" href="/wally-wally-til/assets/js/12.07ea1bdf.js" as="script"><link rel="prefetch" href="/wally-wally-til/assets/js/10.d9a95bfe.js"><link rel="prefetch" href="/wally-wally-til/assets/js/11.a2a6e0bb.js"><link rel="prefetch" href="/wally-wally-til/assets/js/13.1bfbaa6f.js"><link rel="prefetch" href="/wally-wally-til/assets/js/14.90ad19d6.js"><link rel="prefetch" href="/wally-wally-til/assets/js/15.f50c2694.js"><link rel="prefetch" href="/wally-wally-til/assets/js/16.85e8420c.js"><link rel="prefetch" href="/wally-wally-til/assets/js/17.872b0e5a.js"><link rel="prefetch" href="/wally-wally-til/assets/js/18.f1794982.js"><link rel="prefetch" href="/wally-wally-til/assets/js/19.786141e4.js"><link rel="prefetch" href="/wally-wally-til/assets/js/20.88ff03b1.js"><link rel="prefetch" href="/wally-wally-til/assets/js/21.fd903a51.js"><link rel="prefetch" href="/wally-wally-til/assets/js/22.d215abd1.js"><link rel="prefetch" href="/wally-wally-til/assets/js/23.44ffc4f2.js"><link rel="prefetch" href="/wally-wally-til/assets/js/24.01293f45.js"><link rel="prefetch" href="/wally-wally-til/assets/js/25.3ef63158.js"><link rel="prefetch" href="/wally-wally-til/assets/js/26.a467aa9c.js"><link rel="prefetch" href="/wally-wally-til/assets/js/27.9e7ecb66.js"><link rel="prefetch" href="/wally-wally-til/assets/js/28.2ab87b73.js"><link rel="prefetch" href="/wally-wally-til/assets/js/29.4481ba0f.js"><link rel="prefetch" href="/wally-wally-til/assets/js/3.c603572a.js"><link rel="prefetch" href="/wally-wally-til/assets/js/30.19fd5f37.js"><link rel="prefetch" href="/wally-wally-til/assets/js/31.d5bfcc5a.js"><link rel="prefetch" href="/wally-wally-til/assets/js/32.5ee24aeb.js"><link rel="prefetch" href="/wally-wally-til/assets/js/33.11913056.js"><link rel="prefetch" href="/wally-wally-til/assets/js/34.31af5972.js"><link rel="prefetch" href="/wally-wally-til/assets/js/35.9ae3b57d.js"><link rel="prefetch" href="/wally-wally-til/assets/js/36.39511f04.js"><link rel="prefetch" href="/wally-wally-til/assets/js/37.298faa13.js"><link rel="prefetch" href="/wally-wally-til/assets/js/38.04a5a190.js"><link rel="prefetch" href="/wally-wally-til/assets/js/39.02659111.js"><link rel="prefetch" href="/wally-wally-til/assets/js/4.ed8f2e2d.js"><link rel="prefetch" href="/wally-wally-til/assets/js/40.e5fe29a8.js"><link rel="prefetch" href="/wally-wally-til/assets/js/41.2e0f3c4d.js"><link rel="prefetch" href="/wally-wally-til/assets/js/42.604fb7ae.js"><link rel="prefetch" href="/wally-wally-til/assets/js/43.7be3d9b4.js"><link rel="prefetch" href="/wally-wally-til/assets/js/44.6a25a594.js"><link rel="prefetch" href="/wally-wally-til/assets/js/45.3d5db9fb.js"><link rel="prefetch" href="/wally-wally-til/assets/js/46.f541a5fe.js"><link rel="prefetch" href="/wally-wally-til/assets/js/47.493907b1.js"><link rel="prefetch" href="/wally-wally-til/assets/js/48.8846fba8.js"><link rel="prefetch" href="/wally-wally-til/assets/js/49.180ec634.js"><link rel="prefetch" href="/wally-wally-til/assets/js/5.16508133.js"><link rel="prefetch" href="/wally-wally-til/assets/js/50.43c8c2f2.js"><link rel="prefetch" href="/wally-wally-til/assets/js/51.cf749cf9.js"><link rel="prefetch" href="/wally-wally-til/assets/js/52.99331d67.js"><link rel="prefetch" href="/wally-wally-til/assets/js/53.efc989ab.js"><link rel="prefetch" href="/wally-wally-til/assets/js/54.6d56ccbb.js"><link rel="prefetch" href="/wally-wally-til/assets/js/55.0c06e067.js"><link rel="prefetch" href="/wally-wally-til/assets/js/56.b45e191a.js"><link rel="prefetch" href="/wally-wally-til/assets/js/57.961440e9.js"><link rel="prefetch" href="/wally-wally-til/assets/js/58.a3d99037.js"><link rel="prefetch" href="/wally-wally-til/assets/js/59.55d3c672.js"><link rel="prefetch" href="/wally-wally-til/assets/js/6.c7b54f12.js"><link rel="prefetch" href="/wally-wally-til/assets/js/60.1eb9e815.js"><link rel="prefetch" href="/wally-wally-til/assets/js/61.60cf2957.js"><link rel="prefetch" href="/wally-wally-til/assets/js/62.060bd05f.js"><link rel="prefetch" href="/wally-wally-til/assets/js/63.f005f9ad.js"><link rel="prefetch" href="/wally-wally-til/assets/js/64.a7d460aa.js"><link rel="prefetch" href="/wally-wally-til/assets/js/65.083b5915.js"><link rel="prefetch" href="/wally-wally-til/assets/js/66.3f31ca88.js"><link rel="prefetch" href="/wally-wally-til/assets/js/67.affe2987.js"><link rel="prefetch" href="/wally-wally-til/assets/js/68.58b01f3c.js"><link rel="prefetch" href="/wally-wally-til/assets/js/69.c7491bbb.js"><link rel="prefetch" href="/wally-wally-til/assets/js/7.233f38d3.js"><link rel="prefetch" href="/wally-wally-til/assets/js/70.9c9e05e7.js"><link rel="prefetch" href="/wally-wally-til/assets/js/71.67c4633a.js"><link rel="prefetch" href="/wally-wally-til/assets/js/72.66a1fbf9.js"><link rel="prefetch" href="/wally-wally-til/assets/js/73.cc121e7e.js"><link rel="prefetch" href="/wally-wally-til/assets/js/74.b71f297f.js"><link rel="prefetch" href="/wally-wally-til/assets/js/75.24c397b2.js"><link rel="prefetch" href="/wally-wally-til/assets/js/8.f792d4e1.js"><link rel="prefetch" href="/wally-wally-til/assets/js/9.897445a3.js">
    <link rel="stylesheet" href="/wally-wally-til/assets/css/0.styles.5b0b7f0f.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/wally-wally-til/" class="home-link router-link-active"><img src="/wally-wally-til/logo.png" alt="wally-wally TIL" class="logo"> <span class="site-name can-hide">wally-wally TIL</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/wally-wally-til/til/" class="nav-link router-link-active">
  TIL
</a></div><div class="nav-item"><a href="/wally-wally-til/config/" class="nav-link">
  Config
</a></div><div class="nav-item"><a href="https://wally-wally.kr" target="_blank" rel="noopener noreferrer" class="nav-link external">
  wally-wally
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/wally-wally-til/til/" class="nav-link router-link-active">
  TIL
</a></div><div class="nav-item"><a href="/wally-wally-til/config/" class="nav-link">
  Config
</a></div><div class="nav-item"><a href="https://wally-wally.kr" target="_blank" rel="noopener noreferrer" class="nav-link external">
  wally-wally
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></div> <!----></nav>  <ul class="sidebar-links"><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>Introduction</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>JS Deep Dive</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading open"><span>Effective TypeScript</span> <span class="arrow down"></span></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/wally-wally-til/til/effective-typescript/" aria-current="page" class="sidebar-link">Overview</a></li><li><a href="/wally-wally-til/til/effective-typescript/item01-05.html" class="sidebar-link">Item01-05</a></li><li><a href="/wally-wally-til/til/effective-typescript/item06-10.html" aria-current="page" class="active sidebar-link">Item06-10</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/wally-wally-til/til/effective-typescript/item06-10.html#item06-편집기를-사용하여-타입-시스템-탐색하기" class="sidebar-link">Item06. 편집기를 사용하여 타입 시스템 탐색하기</a></li><li class="sidebar-sub-header"><a href="/wally-wally-til/til/effective-typescript/item06-10.html#item07-타입이-값들의-집합이라고-생각하기" class="sidebar-link">Item07. 타입이 값들의 집합이라고 생각하기</a></li><li class="sidebar-sub-header"><a href="/wally-wally-til/til/effective-typescript/item06-10.html#item08-타입-공간과-값-공간의-심벌-구분하기" class="sidebar-link">Item08. 타입 공간과 값 공간의 심벌 구분하기</a></li><li class="sidebar-sub-header"><a href="/wally-wally-til/til/effective-typescript/item06-10.html#item09-타입-단언보다는-타입-선언을-사용하기" class="sidebar-link">Item09. 타입 단언보다는 타입 선언을 사용하기</a></li><li class="sidebar-sub-header"><a href="/wally-wally-til/til/effective-typescript/item06-10.html#item10-객체-래퍼-타입-피하기" class="sidebar-link">Item10. 객체 래퍼 타입 피하기</a></li></ul></li><li><a href="/wally-wally-til/til/effective-typescript/item11-15.html" class="sidebar-link">Item11-15</a></li><li><a href="/wally-wally-til/til/effective-typescript/item16-18.html" class="sidebar-link">Item16-18</a></li><li><a href="/wally-wally-til/til/effective-typescript/item19-23.html" class="sidebar-link">Item19-23</a></li><li><a href="/wally-wally-til/til/effective-typescript/item24-28.html" class="sidebar-link">Item24-28</a></li><li><a href="/wally-wally-til/til/effective-typescript/item29-33.html" class="sidebar-link">Item29-33</a></li><li><a href="/wally-wally-til/til/effective-typescript/item34-38.html" class="sidebar-link">Item34-38</a></li><li><a href="/wally-wally-til/til/effective-typescript/item39-43.html" class="sidebar-link">Item39-43</a></li><li><a href="/wally-wally-til/til/effective-typescript/item44-48.html" class="sidebar-link">Item44-48</a></li><li><a href="/wally-wally-til/til/effective-typescript/item49-51.html" class="sidebar-link">Item49-51</a></li></ul></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>Refactoring</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>Functional Coding</span> <span class="arrow right"></span></p> <!----></section></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h1 id="item06-10"><a href="#item06-10" class="header-anchor">#</a> 📄 Item06 ~ 10</h1> <br> <h2 id="item06-편집기를-사용하여-타입-시스템-탐색하기"><a href="#item06-편집기를-사용하여-타입-시스템-탐색하기" class="header-anchor">#</a> Item06. 편집기를 사용하여 타입 시스템 탐색하기</h2> <ul><li>편집기는 코드를 빌드하고 타입 시스템을 익힐 수 있는 최고의 수단이다.</li> <li>편집기는 타입스크립트가 언제 타입 추론을 수행할 수 있는지에 대한 개념을 잡게 해 주는데, 이 개념을 확실히 잡아야 간결하고 읽기 쉬운 코드를 작성할 수 있다.</li> <li>편집기마다 조금씩 다르지만 보통의 경우 심벌 위에 마우스 커서를 대면 타입스크립트가 그 타입을 어떻게 판단하고 있는지 확인할 수 있다.</li> <li>객체에서는 개별 속성을 살펴봄으로써 타입스크립트가 어떻게 각각의 속성을 추론하는지 살펴볼 수 있다.</li> <li>실제 코드에서 함수 호출이 길게 이어진다면 추론 정보는 디버깅하는데 꼭 필요하다.</li> <li>편집기상의 타입 오류를 살펴보는 것도 타입 시스템의 성향을 파악하는 데 좋은 방법이다.</li></ul> <hr> <ul><li>오류 파악 예시</li></ul> <div class="language-typescript extra-class"><pre class="language-typescript"><code><span class="token keyword">function</span> <span class="token function">getElement</span><span class="token punctuation">(</span>elOrId<span class="token operator">:</span> <span class="token builtin">string</span> <span class="token operator">|</span> HTMLElement <span class="token operator">|</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token operator">:</span> HTMLElement <span class="token punctuation">{</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">typeof</span> elOrId <span class="token operator">===</span> <span class="token string">'object'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> elOrId<span class="token punctuation">;</span> <span class="token comment">// 'HTMLElement | null' 형식은 'HTMLElement' 형식에 할당할 수 없습니다.</span>
  <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>elOrId <span class="token operator">===</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> document<span class="token punctuation">.</span>body<span class="token punctuation">;</span>
  <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
    <span class="token keyword">const</span> el <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">getElementById</span><span class="token punctuation">(</span>elOrId<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> el<span class="token punctuation">;</span> <span class="token comment">// 'HTMLElement | null' 형식은 'HTMLElement' 형식에 할당할 수 없습니다.</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><ul><li>위 예제에서 첫 번째 분기 처리문에서 오류가 발생한 이유는 <code>typeof null</code>도 <code>&quot;object&quot;</code> 이므로 <code>elOrId</code>는 여전히 해당 분기문 내에서 <code>null</code> 일 가능성이 있다.
<ul><li>그렇기 때문에 처음에 <code>null</code> 체크를 추가해서 바로잡아야 한다.</li></ul></li> <li>두 번째 오류는 <code>document.getElementById</code>가 여전히 <code>null</code>을 반환할 수 있기 때문에 첫 번째 오류와 동일하게 <code>null</code> 체크를 해줘야 한다.</li></ul> <hr> <ul><li>타입 선언(<code>d.ts</code> 파일)은 처음에는 이해하기 어렵지만 타입스크립트가 무엇을 하는지, 어떻게 라이브러리가 모델링되었는지, 어떻게 오류를 찾아낼지 살펴볼 수 있는 훌륭한 수단이 된다.</li></ul> <br> <h2 id="item07-타입이-값들의-집합이라고-생각하기"><a href="#item07-타입이-값들의-집합이라고-생각하기" class="header-anchor">#</a> Item07. 타입이 값들의 집합이라고 생각하기</h2> <ul><li>코드가 실행되기 전, 즉 타입스크립트가 오류를 체크하는 순간에는 '타입'을 가지고 있다.
<ul><li>'할당 가능한 값들의 집합'이 타입이라고 생각하면 된다.</li> <li>이 집합은 타입의 '범위'라고 부르기도 한다.</li></ul></li></ul> <br> <ul><li><p>가장 작은 집합은 아무 것도 포함하지 않는 공집합이며, 타입스크립트에서는 <code>never</code> 타입이다.</p> <ul><li>이 타입으로 선언된 변수의 범위는 공집합이므로 아무런 값도 할당할 수 없다.</li></ul></li> <li><p>유닛 타입(리터럴 타입) : <code>never</code> 타입 다음으로 작은 집합인 한 가지 값만 포함하는 타입</p></li> <li><p>유니온 타입 : 값 집합들의 합집합을 의미하며 타입들을 <code>|</code>으로 묶어준다.</p></li> <li><p>'할당 가능한'의 의미</p> <ul><li>집합의 관점에서, '~의 원소(값과 타입의 관계)' 또는 '~의 부분집합(두 타입의 관계)'을 의미</li></ul></li> <li><p>집합의 관점에서, 타입 체커의 주요 역할은 하나의 집합이 다른 집합의 부분 집합인지 검사하는 것이라고 볼 수 있다.</p></li> <li><p>인터섹션 타입 : 두 타입의 교집합을 의미하며 <code>&amp;</code> 연산자로 이어준다.</p></li></ul> <div class="language-typescript extra-class"><pre class="language-typescript"><code><span class="token keyword">interface</span> <span class="token class-name">Person</span> <span class="token punctuation">{</span>
  name<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">interface</span> <span class="token class-name">Lifespan</span> <span class="token punctuation">{</span>
  birth<span class="token operator">:</span> Date<span class="token punctuation">;</span>
  death<span class="token operator">?</span><span class="token operator">:</span> Date<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">type</span> <span class="token class-name">PersonSpan</span> <span class="token operator">=</span> Person <span class="token operator">&amp;</span> Lifespan<span class="token punctuation">;</span>

<span class="token keyword">const</span> ps<span class="token operator">:</span> PersonSpan <span class="token operator">=</span> <span class="token punctuation">{</span>
  name<span class="token operator">:</span> <span class="token string">'abc'</span><span class="token punctuation">,</span>
  birth<span class="token operator">:</span> <span class="token keyword">new</span> <span class="token class-name">Date</span><span class="token punctuation">(</span><span class="token string">'1910/01/01'</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
  death<span class="token operator">:</span> <span class="token keyword">new</span> <span class="token class-name">Date</span><span class="token punctuation">(</span><span class="token string">'1966/12/21'</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span> <span class="token comment">// 정상</span>
</code></pre></div><ul><li>당연히 앞의 세 가지보다 더 많은 속성을 가지는 값도 <code>PersonSpan</code> 타입에 속한다.</li></ul> <div class="language-typescript extra-class"><pre class="language-typescript"><code><span class="token keyword">keyof</span> <span class="token punctuation">(</span><span class="token constant">A</span> <span class="token operator">&amp;</span> <span class="token constant">B</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">keyof</span> <span class="token constant">A</span><span class="token punctuation">)</span> <span class="token operator">|</span> <span class="token punctuation">(</span><span class="token keyword">keyof</span> <span class="token constant">B</span><span class="token punctuation">)</span>
<span class="token keyword">keyof</span> <span class="token punctuation">(</span><span class="token constant">A</span> <span class="token operator">|</span> <span class="token constant">B</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">keyof</span> <span class="token constant">A</span> <span class="token operator">&amp;</span> <span class="token keyword">keyof</span> <span class="token constant">B</span><span class="token punctuation">)</span>
</code></pre></div><br> <ul><li>일반적으로는 인터섹션보다 <code>extends</code> 키워드를 사용해서 타입을 선언한다.</li></ul> <div class="language-typescript extra-class"><pre class="language-typescript"><code><span class="token keyword">interface</span> <span class="token class-name">Person</span> <span class="token punctuation">{</span>
  name<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">interface</span> <span class="token class-name">PersonSpan</span> <span class="token keyword">extends</span> <span class="token class-name">Person</span> <span class="token punctuation">{</span>
  birth<span class="token operator">:</span> Date<span class="token punctuation">;</span>
  death<span class="token operator">?</span><span class="token operator">:</span> Date<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><ul><li><code>extends</code> 의 의미는 '~에 할당 가능한'과 비슷하게, '~의 부분 집합'이라는 의미로 받아들일 수 있다.</li> <li><code>extends</code> 키워드는 제네릭 타입에서 한정자로도 쓰이며, 이 문맥에서는 '~의 부분 집합'을 의미하기도 한다.</li></ul> <br> <ul><li><code>keyof</code>를 통해 할당과 상속 관계 살펴보기</li></ul> <div class="language-typescript extra-class"><pre class="language-typescript"><code><span class="token keyword">interface</span> <span class="token class-name">Point</span> <span class="token punctuation">{</span>
  x<span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">;</span>
  y<span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">type</span> <span class="token class-name">PointKeys</span> <span class="token operator">=</span> <span class="token keyword">keyof</span> Point<span class="token punctuation">;</span> <span class="token comment">// 타입은 &quot;x&quot; | &quot;y&quot;</span>

<span class="token keyword">function</span> <span class="token generic-function"><span class="token function">sortBy</span><span class="token generic class-name"><span class="token operator">&lt;</span><span class="token constant">K</span> <span class="token keyword">extends</span> <span class="token keyword">keyof</span> <span class="token constant">T</span><span class="token punctuation">,</span> <span class="token constant">T</span><span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span>vals<span class="token operator">:</span> <span class="token constant">T</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span> key<span class="token operator">:</span> <span class="token constant">K</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token constant">T</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token punctuation">{</span>
  <span class="token comment">// ...</span>
<span class="token punctuation">}</span>

<span class="token keyword">const</span> pts<span class="token operator">:</span> Point<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">[</span>
  <span class="token punctuation">{</span> x<span class="token operator">:</span> <span class="token number">1</span><span class="token punctuation">,</span> y<span class="token operator">:</span> <span class="token number">1</span> <span class="token punctuation">}</span><span class="token punctuation">,</span>
  <span class="token punctuation">{</span> x<span class="token operator">:</span> <span class="token number">2</span><span class="token punctuation">,</span> y<span class="token operator">:</span> <span class="token number">0</span> <span class="token punctuation">}</span><span class="token punctuation">,</span>
<span class="token punctuation">]</span><span class="token punctuation">;</span>

<span class="token function">sortBy</span><span class="token punctuation">(</span>pts<span class="token punctuation">,</span> <span class="token string">'x'</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 정상, 'x'는 'x' | 'y'를 상속 (즉, keyof T)</span>
<span class="token function">sortBy</span><span class="token punctuation">(</span>pts<span class="token punctuation">,</span> <span class="token string">'y'</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 정상, 'y'는 'x' | 'y'를 상속</span>
<span class="token function">sortBy</span><span class="token punctuation">(</span>pts<span class="token punctuation">,</span> Math<span class="token punctuation">.</span><span class="token function">randomm</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;</span> <span class="token number">0.5</span> <span class="token operator">?</span> <span class="token string">'x'</span> <span class="token operator">:</span> <span class="token string">'y'</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 정상, 'x' | 'y는 'x' | 'y'를 상속</span>
<span class="token function">sortBy</span><span class="token punctuation">(</span>pts<span class="token punctuation">,</span> <span class="token string">'z'</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// '&quot;z&quot;' 형식의 인수는 '&quot;x&quot; | &quot;y&quot;' 형식의 매개변수에 할당될 수 없습니다.</span>
</code></pre></div><br> <ul><li>타입이 집합이라는 관점을 배열과 튜플의 관계 역시 명확하게 만든다.</li></ul> <div class="language-typescript extra-class"><pre class="language-typescript"><code><span class="token keyword">const</span> triple<span class="token operator">:</span> <span class="token punctuation">[</span><span class="token builtin">number</span><span class="token punctuation">,</span> <span class="token builtin">number</span><span class="token punctuation">,</span> <span class="token builtin">number</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token keyword">const</span> double<span class="token operator">:</span> <span class="token punctuation">[</span><span class="token builtin">number</span><span class="token punctuation">,</span> <span class="token builtin">number</span><span class="token punctuation">]</span> <span class="token operator">=</span> triple<span class="token punctuation">;</span>
<span class="token comment">// '[number, number, number]' 형식은</span>
<span class="token comment">// '[number, number]' 형식에 할당할 수 없습니다.</span>
<span class="token comment">// 'length' 속성의 형식이 호환되지 않습니다.</span>
<span class="token comment">// '3' 형식은 '2' 형식에 할당할 수 없습니다.</span>
</code></pre></div><ul><li>쌍에서 길이를 체크하는 것은 합리적이며, 이보다 나은 방법은 없을 것이다.</li></ul> <br> <p>💡 <b>결론!</b></p> <blockquote><p>타입을 값의 집합으로 생각하면 이해하기 편하고 '상속', '할당 가능', '서브 타입'은 '부분 집합'과 같은 의미로 받아들이면 편하다.</p></blockquote> <br> <h2 id="item08-타입-공간과-값-공간의-심벌-구분하기"><a href="#item08-타입-공간과-값-공간의-심벌-구분하기" class="header-anchor">#</a> Item08. 타입 공간과 값 공간의 심벌 구분하기</h2> <div class="language-typescript extra-class"><pre class="language-typescript"><code><span class="token keyword">interface</span> <span class="token class-name">Cylinder</span> <span class="token punctuation">{</span>
  radius<span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">;</span>
  height<span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">const</span> <span class="token function-variable function">Cylinder</span> <span class="token operator">=</span> <span class="token punctuation">(</span>radius<span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">,</span> height<span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">(</span><span class="token punctuation">{</span> radius<span class="token punctuation">,</span> height <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><ul><li><code>interface Cylinder</code>에서 <code>Cylinder</code>는 타입으로 쓰이고, <code>const Cylinder</code>에서 <code>Cylinder</code>는 이름은 같지만 값으로 쓰이며, 서로 아무런 관련도 없다.
<ul><li>상황에 따라 <code>Cylinder</code>는 타입으로 쓰일 수도 있고, 값으로 쓰일 수도 있다.</li></ul></li></ul> <div class="language-typescript extra-class"><pre class="language-typescript"><code><span class="token keyword">function</span> <span class="token function">calculateVolume</span><span class="token punctuation">(</span>shape<span class="token operator">:</span> <span class="token builtin">unknown</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>shape <span class="token keyword">instanceof</span> <span class="token class-name">Cylinder</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token builtin">console</span><span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>shape<span class="token punctuation">.</span>radius<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// '{}' 형식에 'radius' 속성이 없습니다.</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><ul><li>하지만 위 코드와 같은 오류가 발생하곤 한다.
<ul><li><code>instanceof</code>를 이용해 <code>shape</code>가 <code>Cylinder</code> 타입인지 체크하려고 하는 구문인데, <code>instancof</code>는 자바스크립트의 런타임 연산자이고, 값에 대해서 연산을 한다.</li> <li>그래서 <code>instanceof Cylinder</code>는 타입이 아니라 함수를 참조하게 된다.</li></ul></li></ul> <br> <ul><li><code>class</code>와 <code>enum</code>은 상황에 따라 타입과 값 두 가지 모두 가능한 예약어이다.</li></ul> <div class="language-typescript extra-class"><pre class="language-typescript"><code><span class="token keyword">class</span> <span class="token class-name">Cylinder</span> <span class="token punctuation">{</span>
  radius <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
  height <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">function</span> <span class="token function">calculateVolume</span><span class="token punctuation">(</span>shape<span class="token operator">:</span> <span class="token builtin">unknown</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>shape <span class="token keyword">instanceof</span> <span class="token class-name">Cylinder</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token builtin">console</span><span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>shape<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 정상, 타입은 Cylinder</span>
    <span class="token builtin">console</span><span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>shape<span class="token punctuation">.</span>raidus<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 정상, 타입은 number</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><ul><li>클래스가 타입으로 쓰일 때는 형태(속성과 메서드)가 사용되는 반면, 값으로 쓰일 대는 생성자가 사용된다.</li></ul> <br> <ul><li><code>typeof</code>도 타입과 값에서 쓰일 때 서로 다른 기능을 한다.</li></ul> <div class="language-typescript extra-class"><pre class="language-typescript"><code><span class="token keyword">type</span> <span class="token class-name"><span class="token constant">T1</span></span> <span class="token operator">=</span> <span class="token keyword">typeof</span> p<span class="token punctuation">;</span> <span class="token comment">// 타입은 Person</span>
<span class="token keyword">type</span> <span class="token class-name"><span class="token constant">T2</span></span> <span class="token operator">=</span> <span class="token keyword">typeof</span> email<span class="token punctuation">;</span> <span class="token comment">// 타입은 (p: Person, subject: string, body: string) =&gt; Response</span>

<span class="token keyword">const</span> v1 <span class="token operator">=</span> <span class="token keyword">typeof</span> p<span class="token punctuation">;</span> <span class="token comment">// 값은 &quot;object&quot;</span>
<span class="token keyword">const</span> v2 <span class="token operator">=</span> <span class="token keyword">typeof</span> email<span class="token punctuation">;</span> <span class="token comment">// 값은 &quot;function&quot;</span>

<span class="token keyword">const</span> v <span class="token operator">=</span> <span class="token keyword">typeof</span> Cylinder<span class="token punctuation">;</span> <span class="token comment">// 값이 &quot;function&quot;</span>
<span class="token keyword">type</span> <span class="token class-name"><span class="token constant">T</span></span> <span class="token operator">=</span> <span class="token keyword">typeof</span> Cylinder<span class="token punctuation">;</span> <span class="token comment">// 타입이 typeof Cylinder(Cylinder가 인스턴스의 타입이 아니라 실제로는 new 키워드를 사용할 때 볼 수 있는 생성자 함수이다.)</span>
</code></pre></div><ul><li><p>타입의 관점</p> <ul><li>값을 읽어서 타입스크립트의 타입을 반환</li> <li>타입 공간의 <code>typeof</code>는 보다 큰 타입의 일부분으로 사용할 수 있고, <code>type</code> 구문으로 이름을 붙이는 용도로도 사용할 수 있음</li></ul></li> <li><p>값의 관점</p> <ul><li>자바스크립트 런타임의 <code>typeof</code> 연산자가 된다.</li> <li>대상 심벌의 런타임 타입을 가리키는 문자열을 반환</li> <li>자바스크립트에는 과거부터 지금까지 단 6개(<code>string</code>, <code>number</code>, <code>boolean</code>, <code>undefined</code>, <code>object</code>, <code>function</code>)의 런타임 타입만이 존재</li></ul></li> <li><p><code>InstanceType</code> 이라는 유틸리티 타입을 통해 생성자의 타입과 인스턴스 타입을 전환할 수 있다.</p></li></ul> <br> <ul><li>속성 접근자인 <code>[]</code>는 타입으로 쓰일 때에도 동일하게 동작한다.
<ul><li>그러나 <code>obj['field']</code>와 <code>obj.field</code>는 값이 동일하더라도 타입은 다를 수 있다.</li> <li>따라서 타입의 속성을 얻을 때에는 반드시 첫 번째 방법인 <code>obj['field']</code>를 사용해야 한다.</li></ul></li></ul> <div class="language-typescript extra-class"><pre class="language-typescript"><code><span class="token keyword">const</span> first<span class="token operator">:</span> Person<span class="token punctuation">[</span><span class="token string">'first'</span><span class="token punctuation">]</span> <span class="token operator">=</span> p<span class="token punctuation">[</span><span class="token string">'first'</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">// 또는 값 작성시 p.first</span>
</code></pre></div><ul><li>이 때 인덱스 위치에는 유니온 타입과 기본형 타입을 포함한 어떠한 타입이든 사용할 수 있다.</li></ul> <div class="language-typescript extra-class"><pre class="language-typescript"><code><span class="token keyword">type</span> <span class="token class-name">PersonEl</span> <span class="token operator">=</span> Person<span class="token punctuation">[</span><span class="token string">'first'</span> <span class="token operator">|</span> <span class="token string">'last'</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">// 타입은 string</span>
<span class="token keyword">type</span> <span class="token class-name">Tuple</span> <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token builtin">string</span><span class="token punctuation">,</span> <span class="token builtin">number</span><span class="token punctuation">,</span> Date<span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token keyword">type</span> <span class="token class-name">TupleEl</span> <span class="token operator">=</span> Tuple<span class="token punctuation">[</span><span class="token builtin">number</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">// 타입은 string | number | Date</span>
</code></pre></div><hr> <h4 id="타입-공간과-값-공간-사이에서-다른-의미를-가지는-코드-패턴"><a href="#타입-공간과-값-공간-사이에서-다른-의미를-가지는-코드-패턴" class="header-anchor">#</a> ➕ 타입 공간과 값 공간 사이에서 다른 의미를 가지는 코드 패턴</h4> <ul><li><code>this</code> 키워드</li> <li><code>&amp;</code>, <code>|</code> 키워드
<ul><li>값으로 쓰이면 AND와 OR 연산</li> <li>타입으로 쓰이면 인터섹션 타입과 유니온 타입</li></ul></li> <li><code>const</code>는 새 변수를 선언하지만, <code>as const</code>는 리터럴 또는 리터럴 표현식의 추론된 타입을 바꿈</li> <li><code>extends</code> 키워드
<ul><li>서브 클래스(<code>class A extends B</code>) 또는 서브타입(<code>interface A extends B</code>) 또는 제네릭 타입의 한정자(<code>Generic&lt;T extends number&gt;</code>)를 정의할 수 있음</li></ul></li> <li><code>in</code> 키워드
<ul><li>값으로 쓰이면 루프(<code>for (key in object)</code>)</li> <li>타입으로 쓰이면 매핑된(mapped) 타입</li></ul></li></ul> <hr> <h4 id="구조-분해-문법-사용시-주의하자"><a href="#구조-분해-문법-사용시-주의하자" class="header-anchor">#</a> ⚠️ 구조 분해 문법 사용시 주의하자</h4> <div class="language-typescript extra-class"><pre class="language-typescript"><code><span class="token keyword">function</span> <span class="token function">email</span><span class="token punctuation">(</span>options<span class="token operator">:</span> <span class="token punctuation">{</span>person<span class="token operator">:</span> Person<span class="token punctuation">,</span> subject<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">,</span> body<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">}</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
</code></pre></div><div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token comment">// 자바스크립트에서 구조 분해 문법 사용시</span>
<span class="token keyword">function</span> <span class="token function">email</span><span class="token punctuation">(</span><span class="token parameter"><span class="token punctuation">{</span>email<span class="token punctuation">,</span> subject<span class="token punctuation">,</span> body<span class="token punctuation">}</span></span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
</code></pre></div><div class="language-typescript extra-class"><pre class="language-typescript"><code><span class="token comment">// 타입스크립트에서 구조 분해 문법 잘못 사용한 예시</span>
<span class="token keyword">function</span> <span class="token function">email</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
  person<span class="token operator">:</span> Person<span class="token punctuation">,</span> <span class="token comment">// 바인딩 요소 'Person'에 암시적으로 'any' 형식이 있습니다.</span>
  subject<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">,</span> <span class="token comment">// 'string' 식별자가 중복되었습니다. 바인딩 요소 'string'에 암시적으로 'any' 형식이 있습니다.</span>
  body<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">,</span> <span class="token comment">// 'string' 식별자가 중복되었습니다. 바인딩 요소 'string'에 암시적으로 'any' 형식이 있습니다.</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
</code></pre></div><ul><li>값의 관점에서 <code>Person</code>과 <code>string</code>이 해석되었기 때문에 오류가 발생했다.
<ul><li><code>Person</code>이라는 변수명과 <code>string</code>이라는 이름을 가지는 두 개의 변수를 생성하려한 것이다.</li> <li>문제를 해결하려면 아래와 같이 타입과 값을 구분해야 한다.</li></ul></li></ul> <div class="language-typescript extra-class"><pre class="language-typescript"><code><span class="token comment">// 타입스크립트에서 구조 분해 문법을 올바르게 사용한 예시</span>
<span class="token keyword">function</span> <span class="token function">email</span><span class="token punctuation">(</span><span class="token punctuation">{</span>person<span class="token punctuation">,</span> subject<span class="token punctuation">,</span> body<span class="token punctuation">}</span><span class="token operator">:</span> <span class="token punctuation">{</span>person<span class="token operator">:</span> Person<span class="token punctuation">,</span> subject<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">,</span> body<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">}</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
</code></pre></div><hr> <br> <h2 id="item09-타입-단언보다는-타입-선언을-사용하기"><a href="#item09-타입-단언보다는-타입-선언을-사용하기" class="header-anchor">#</a> Item09. 타입 단언보다는 타입 선언을 사용하기</h2> <h3 id="_1-타입-선언과-타입-단언"><a href="#_1-타입-선언과-타입-단언" class="header-anchor">#</a> (1) 타입 선언과 타입 단언</h3> <div class="language-typescript extra-class"><pre class="language-typescript"><code><span class="token keyword">interface</span> <span class="token class-name">Person</span> <span class="token punctuation">{</span>
  name<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">const</span> alice<span class="token operator">:</span> Person <span class="token operator">=</span> <span class="token punctuation">{</span> name<span class="token operator">:</span> <span class="token string">'Alice'</span> <span class="token punctuation">}</span><span class="token punctuation">;</span> <span class="token comment">// 타입 선언</span>
<span class="token keyword">const</span> bob <span class="token operator">=</span> <span class="token punctuation">{</span> name<span class="token operator">:</span> <span class="token string">'Bob'</span> <span class="token punctuation">}</span> <span class="token keyword">as</span> Person<span class="token punctuation">;</span> <span class="token comment">// 타입 단언</span>
</code></pre></div><ul><li>타입 단언보다는 타입 선언을 사용하는게 낫다.</li></ul> <div class="language-typescript extra-class"><pre class="language-typescript"><code><span class="token keyword">const</span> alice<span class="token operator">:</span> Person <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span> <span class="token comment">// 'Person' 유형에 필요한 'name' 속성이 '{}' 유형에 없습니다.</span>
<span class="token keyword">const</span> bob <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span> <span class="token keyword">as</span> Person<span class="token punctuation">;</span> <span class="token comment">// 오류 없음</span>
</code></pre></div><ul><li>타입 선언은 할당되는 값이 해당 인터페이스를 만족하는지 검사한다.</li> <li>타입 단언은 강제로 타입을 지정했으니 타입 체커에게 오류를 무시하라고 하는 것이다.</li> <li>타입 단언이 꼭 필요한 경우가 아니라면, 안전성 체크도 되는 타입 선언을 사용하는 것이 좋다.</li></ul> <br> <h3 id="_2-화살표-함수의-타입-선언"><a href="#_2-화살표-함수의-타입-선언" class="header-anchor">#</a> (2) 화살표 함수의 타입 선언</h3> <div class="language-typescript extra-class"><pre class="language-typescript"><code><span class="token keyword">const</span> people <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">'alice'</span><span class="token punctuation">,</span> <span class="token string">'bob'</span><span class="token punctuation">,</span> <span class="token string">'jan'</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">(</span>
  <span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token operator">:</span> Person <span class="token operator">=&gt;</span> <span class="token punctuation">(</span><span class="token punctuation">{</span>name<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 타입은 Person[]</span>
</code></pre></div><ul><li>위 코드에서 소괄호는 매우 중요한 의미를 지닌다.
<ul><li><code>(name): Person</code>은 <code>name</code>의 타입이 없고, 반환 타입이 <code>Person</code>이라고 명시한다.</li> <li>그러나 <code>(name: Person)</code>은 <code>name</code>의 타입이 <code>Person</code>임을 명시하고 반환 타입은 없기 때문에 오류가 발생한다.</li></ul></li></ul> <div class="language-typescript extra-class"><pre class="language-typescript"><code><span class="token comment">// 원하는 반환 타입까지 명시한 버전</span>
<span class="token keyword">const</span> people<span class="token operator">:</span> Person<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">'alice'</span><span class="token punctuation">,</span> <span class="token string">'bob'</span><span class="token punctuation">,</span> <span class="token string">'jan'</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">(</span>
  <span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token operator">:</span> Person <span class="token operator">=&gt;</span> <span class="token punctuation">(</span><span class="token punctuation">{</span>name<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><blockquote><p>단, 함수 호출 체이닝이 연속되는 곳에서는 체이닝 시작에서부터 명명된 타입을 가져야 한다.</p> <p>그래야 정확한 곳에 오류가 표시된다.</p></blockquote> <br> <h3 id="_3-타입-단언이-필요한-경우"><a href="#_3-타입-단언이-필요한-경우" class="header-anchor">#</a> (3) 타입 단언이 필요한 경우</h3> <ul><li>타입 체커가 추론한 타입보다 개발자가 직접 판단한 타입이 더 정확할 때 사용한다.</li></ul> <div class="language-typescript extra-class"><pre class="language-typescript"><code>document<span class="token punctuation">.</span><span class="token function">querySelector</span><span class="token punctuation">(</span><span class="token string">'#myButton'</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">addEventListener</span><span class="token punctuation">(</span><span class="token string">'click'</span><span class="token punctuation">,</span> e <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
  e<span class="token punctuation">.</span>currentTarget<span class="token punctuation">;</span> <span class="token comment">// 타입은 EventTarget</span>
  <span class="token keyword">const</span> button <span class="token operator">=</span> e<span class="token punctuation">.</span>currentTarget <span class="token keyword">as</span> HTMLButtonElement<span class="token punctuation">;</span>
  button<span class="token punctuation">;</span> <span class="token comment">// 타입은 HTMLButtonElement</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
</code></pre></div><ul><li>타입스크립트는 DOM에 접근할 수 없기 때문에 <code>#myButton</code>이 버튼 엘리먼트인지 알지 못한다.</li> <li>그리고 이벤트의 <code>currentTarget</code>이 같은 버튼이어야 하는 것도 알지 못한다.</li> <li>개발자는 타입스크립트가 알지 못하는 정보를 가지고 있으므로 여기서는 타입 단언을 쓰는 것이 타당하다.</li></ul> <br> <h3 id="_4-non-null-assertion"><a href="#_4-non-null-assertion" class="header-anchor">#</a> (4) non-null assertion</h3> <div class="language-typescript extra-class"><pre class="language-typescript"><code><span class="token keyword">const</span> elNull <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">getElementById</span><span class="token punctuation">(</span><span class="token string">'foo'</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 타입은 HTMLElement | null</span>
<span class="token keyword">const</span> el <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">getElementById</span><span class="token punctuation">(</span><span class="token string">'foo'</span><span class="token punctuation">)</span><span class="token operator">!</span><span class="token punctuation">;</span> <span class="token comment">// 타입은 HTMLElement</span>
</code></pre></div><ul><li>접미사로 쓰인 <code>!</code>를 통해 타입 체커는 알지 못하지만 그 값이 <code>null</code>이 아니라고 확신할 수 있게 된다.
<ul><li>만약 그렇지 않다면, <code>null</code>인 경우를 체크하는 조건문을 사용해야 한다.</li></ul></li></ul> <br> <h3 id="_5-unknown-타입-단언"><a href="#_5-unknown-타입-단언" class="header-anchor">#</a> (5) <code>unknown</code> 타입 단언</h3> <ul><li>A가 B의 부분 집합인 경우에 타입 단언문을 사용해 변환할 수 있다.</li> <li>이러한 rule을 지키지 않는다면 오류가 발생하는데 이 때 <code>unknown</code> 타입으로 해결할 수 있다.</li> <li>모든 타입은 <code>unknown</code>의 서브타입이기 때문에 이 타입이 포함된 단언문을 항상 동작한다.</li> <li><code>unknown</code> 단언은 임의의 타입 간에 변환을 가능케 하지만, <code>unknown</code>을 사용한 이상 적어도 무언가 위험한 동작을 하고 있다는 걸 알 수 있다.</li></ul> <br> <h2 id="item10-객체-래퍼-타입-피하기"><a href="#item10-객체-래퍼-타입-피하기" class="header-anchor">#</a> Item10. 객체 래퍼 타입 피하기</h2> <ul><li><code>'primitive'.charAt(3);</code>와 같은 코드에서 <code>charAt</code>은 <code>string</code>의 메서드가 아니면, <code>string</code>을 사용할 때 자바스크립트 내부적으로 많은 동작이 일어난다.
<ul><li><code>string</code> 기본형에는 메서드가 없지만, 자바스크립트에는 메서드를 가지는 <code>String</code> 객체 타입이 정의되어 있다.</li> <li><code>string</code> 기본형에 <code>charAt</code> 같은 메서드를 사용할 때, 자바스크립트는 기본형을 <code>String</code> 객체로 래핑(wrap)하고, 메서드를 호출하고, 마지막에 래핑한 객체를 버린다.</li></ul></li> <li>다른 기본형에도 동일하게 객체 래퍼 타입이 존재한다.
<ul><li><code>number</code>에는 <code>Number</code>, <code>boolean</code>에는 <code>Boolean</code> 등...</li> <li>이 래퍼 타입들 덕분에 기본형 값에 메서드를 사용할 수 있고, 정적 메서드(<code>String.fromCharCode</code> 같은)도 사용할 수 있다.</li> <li>그러나 보통은 래퍼 객체를 직접 생성할 필요가 없다.</li></ul></li> <li>타입을 선언할 때 객체 래퍼 타입으로 작성하지 않도록 주의하자.
<ul><li>대부분의 라이브러리와 마찬가지로 타입스크립트가 제공하는 타입 선언은 전부 기본형 타입으로 되어 있다.</li></ul></li> <li>기본형 타입은 객체 래퍼에 할당할 수 있기 때문에 타입스크립트는 기본형 타입을 객체 래퍼에 할당하는 선언을 허용한다.
<ul><li>그러나 기본형 타입을 객체 래퍼에 할당하는 구문은 오해하기 쉽고, 굳이 그렇게 할 필요도 없다.</li> <li>그냥 기본형 타입을 사용하자.</li></ul></li></ul></div> <footer class="page-edit"><!----> <!----></footer> <div class="page-nav"><p class="inner"><span class="prev">
      ←
      <a href="/wally-wally-til/til/effective-typescript/item01-05.html" class="prev">
        Item01-05
      </a></span> <span class="next"><a href="/wally-wally-til/til/effective-typescript/item11-15.html">
        Item11-15
      </a>
      →
    </span></p></div> </main></div><div class="global-ui"></div></div>
    <script src="/wally-wally-til/assets/js/app.f5246800.js" defer></script><script src="/wally-wally-til/assets/js/2.fd76ebd9.js" defer></script><script src="/wally-wally-til/assets/js/12.07ea1bdf.js" defer></script>
  </body>
</html>
