(window.webpackJsonp=window.webpackJsonp||[]).push([[55],{451:function(t,_,l){"use strict";l.r(_);var v=l(56),n=Object(v.a)({},(function(){var t=this,_=t.$createElement,l=t._self._c||_;return l("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[l("h1",{attrs:{id:"_03-05-전역-데이터"}},[l("a",{staticClass:"header-anchor",attrs:{href:"#_03-05-전역-데이터"}},[t._v("#")]),t._v(" 03-05. 전역 데이터")]),t._v(" "),l("br"),t._v(" "),l("h2",{attrs:{id:"intro"}},[l("a",{staticClass:"header-anchor",attrs:{href:"#intro"}},[t._v("#")]),t._v(" ✋ Intro")]),t._v(" "),l("ul",[l("li",[l("p",[t._v("전역 데이터는 코드베이스 어디에서든 건드릴 수 없고 값을 누가 바꿨는지 찾아낼 메커니즘이 없다는 게 문제다.")])]),t._v(" "),l("li",[l("p",[t._v("전역 데이터의 대표적인 형태는 전역 변수지만 클래스 변수와 싱글톤(singleton)에서도 같은 문제가 발생한다.")])])]),t._v(" "),l("hr"),t._v(" "),l("h3",{attrs:{id:"싱글톤-singleton"}},[l("a",{staticClass:"header-anchor",attrs:{href:"#싱글톤-singleton"}},[t._v("#")]),t._v(" ➕ 싱글톤(singleton)")]),t._v(" "),l("ul",[l("li",[t._v("애플리케이션이 시작될 때 어떤 클래스가 "),l("strong",[t._v("최초 한번만")]),t._v(" 메모리를 할당하고(Static) 그 메모리에 인스턴스를 만들어 사용하는 디자인 패턴이다.")]),t._v(" "),l("li",[t._v("생성자가 여러 차례 호출되더라도 실제로 생성되는 객체는 하나고 최초 생성 이후에 호출된 생성자는 최초에 생성한 객체를 반환한다.")]),t._v(" "),l("li",[t._v("고정된 메모리 영역을 얻으면서 한번의 new로 인스턴스를 사용하기 때문에 메모리 낭비를 방지할 수 있다.")]),t._v(" "),l("li",[t._v("또한 싱글톤으로 만들어진 클래스의 인스턴스는 전역 인스턴스이기 때문에 다른 클래스의 인스턴스들이 데이터를 공유하기 쉽다.")]),t._v(" "),l("li",[t._v('싱글톤 인스턴스가 너무 많은 일을 하거나 많은 데이터를 공유시킬 경우 다른 클래스의 인스턴스들 간에 결합도가 높아져 "개방-폐쇄 원칙" 을 위배하게 된다. 따라서 수정이 어려워지고 테스트하기 어려워진다.\n'),l("ul",[l("li",[t._v("개방-폐쇄 원칙((OCP, Open-Closed Principle) : 소프트웨어 개체(클래스, 모듈, 함수 등등)는 확장에 대해 열려 있어야 하고, 수정에 대해서는 닫혀 있어야 한다")])])])]),t._v(" "),l("hr"),t._v(" "),l("ul",[l("li",[t._v("다른 코드에서 오염시킬 가능성이 있는 데이터를 발견할 때마다 변수 캡슐화하기 기법을 적용하면 좋다.\n"),l("ul",[l("li",[t._v("이런 데이터를 함수로 감싸는 것만으로도 데이터를 수정하는 부분을 쉽게 찾을 수 있고 접근을 통제할 수 있게 된다.")]),t._v(" "),l("li",[t._v("더 나아가 접근 범위를 최소로 줄일 수 있다.")])])]),t._v(" "),l("li",[t._v("전역 데이터가 조금뿐이라면 감당할 수 있겠지만, 많아지면 걷잡을 수 없게 된다.")])])])}),[],!1,null,null,null);_.default=n.exports}}]);